// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#include <odb/pre.hxx>

#include "taxi_types-odb.hxx"

#include <cassert>
#include <cstring>  // std::memcpy


#include <odb/mysql/traits.hxx>
#include <odb/mysql/database.hxx>
#include <odb/mysql/transaction.hxx>
#include <odb/mysql/connection.hxx>
#include <odb/mysql/statement.hxx>
#include <odb/mysql/statement-cache.hxx>
#include <odb/mysql/simple-object-statements.hxx>
#include <odb/mysql/container-statements.hxx>
#include <odb/mysql/exceptions.hxx>
#include <odb/mysql/simple-object-result.hxx>
#include <odb/mysql/enum.hxx>

namespace odb
{
  // City
  //

  struct access::object_traits_impl< ::taxi::City, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::City, id_mysql >::id_type
  access::object_traits_impl< ::taxi::City, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::City, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // areaid
    //
    t[1UL] = 0;

    // tag
    //
    t[2UL] = 0;

    // name
    //
    if (t[3UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // notes
    //
    if (t[4UL])
    {
      i.notes_value.capacity (i.notes_size);
      grew = true;
    }

    // __isset
    //
    if (t[5UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::City, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // areaid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.areaid_value;
    b[n].is_null = &i.areaid_null;
    n++;

    // tag
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.tag_value;
    b[n].is_null = &i.tag_null;
    n++;

    // name
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.name_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.name_value.capacity ());
    b[n].length = &i.name_size;
    b[n].is_null = &i.name_null;
    n++;

    // notes
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.notes_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.notes_value.capacity ());
    b[n].length = &i.notes_size;
    b[n].is_null = &i.notes_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::City, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::City, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // areaid
    //
    {
      ::taxi::ID const& v =
        o.areaid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.areaid_value, is_null, v);
      i.areaid_null = is_null;
    }

    // tag
    //
    {
      ::taxi::NUMBER32 const& v =
        o.tag;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.tag_value, is_null, v);
      i.tag_null = is_null;
    }

    // name
    //
    {
      ::taxi::STR const& v =
        o.name;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.name_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.name_value,
        size,
        is_null,
        v);
      i.name_null = is_null;
      i.name_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.name_value.capacity ());
    }

    // notes
    //
    {
      ::taxi::STR const& v =
        o.notes;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.notes_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.notes_value,
        size,
        is_null,
        v);
      i.notes_null = is_null;
      i.notes_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.notes_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_City__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_City__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::City, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // areaid
    //
    {
      ::taxi::ID& v =
        o.areaid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.areaid_value,
        i.areaid_null);
    }

    // tag
    //
    {
      ::taxi::NUMBER32& v =
        o.tag;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.tag_value,
        i.tag_null);
    }

    // name
    //
    {
      ::taxi::STR& v =
        o.name;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // notes
    //
    {
      ::taxi::STR& v =
        o.notes;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.notes_value,
        i.notes_size,
        i.notes_null);
    }

    // __isset
    //
    {
      ::taxi::_City__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_City__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::City, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::City, id_mysql >::persist_statement[] =
  "INSERT INTO `City` "
  "(`id`, "
  "`areaid`, "
  "`tag`, "
  "`name`, "
  "`notes`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::City, id_mysql >::find_statement[] =
  "SELECT "
  "`City`.`id`, "
  "`City`.`areaid`, "
  "`City`.`tag`, "
  "`City`.`name`, "
  "`City`.`notes`, "
  "`City`.`isset` "
  "FROM `City` "
  "WHERE `City`.`id`=?";

  const char access::object_traits_impl< ::taxi::City, id_mysql >::update_statement[] =
  "UPDATE `City` "
  "SET "
  "`areaid`=?, "
  "`tag`=?, "
  "`name`=?, "
  "`notes`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::City, id_mysql >::erase_statement[] =
  "DELETE FROM `City` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::City, id_mysql >::query_statement[] =
  "SELECT "
  "`City`.`id`, "
  "`City`.`areaid`, "
  "`City`.`tag`, "
  "`City`.`name`, "
  "`City`.`notes`, "
  "`City`.`isset` "
  "FROM `City`";

  const char access::object_traits_impl< ::taxi::City, id_mysql >::erase_query_statement[] =
  "DELETE FROM `City`";

  const char access::object_traits_impl< ::taxi::City, id_mysql >::table_name[] =
  "`City`";

  void access::object_traits_impl< ::taxi::City, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::City, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::City, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::City, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::City, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::City, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::City, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::City, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::City, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::City, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::City, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // DictEntry
  //

  struct access::object_traits_impl< ::taxi::DictEntry, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::DictEntry, id_mysql >::id_type
  access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // parent
    //
    t[1UL] = 0;

    // tag
    //
    t[2UL] = 0;

    // idx
    //
    t[3UL] = 0;

    // strvalue
    //
    if (t[4UL])
    {
      i.strvalue_value.capacity (i.strvalue_size);
      grew = true;
    }

    // intvalue
    //
    t[5UL] = 0;

    // __isset
    //
    if (t[6UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // parent
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.parent_value;
    b[n].is_null = &i.parent_null;
    n++;

    // tag
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.tag_value;
    b[n].is_null = &i.tag_null;
    n++;

    // idx
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.idx_value;
    b[n].is_null = &i.idx_null;
    n++;

    // strvalue
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.strvalue_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.strvalue_value.capacity ());
    b[n].length = &i.strvalue_size;
    b[n].is_null = &i.strvalue_null;
    n++;

    // intvalue
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.intvalue_value;
    b[n].is_null = &i.intvalue_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // parent
    //
    {
      ::taxi::ID const& v =
        o.parent;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.parent_value, is_null, v);
      i.parent_null = is_null;
    }

    // tag
    //
    {
      ::taxi::DictTag::type const& v =
        o.tag;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DictTag::type,
          mysql::id_ulong >::set_image (
        i.tag_value, is_null, v);
      i.tag_null = is_null;
    }

    // idx
    //
    {
      ::taxi::NUMBER32 const& v =
        o.idx;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.idx_value, is_null, v);
      i.idx_null = is_null;
    }

    // strvalue
    //
    {
      ::taxi::STR const& v =
        o.strvalue;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.strvalue_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.strvalue_value,
        size,
        is_null,
        v);
      i.strvalue_null = is_null;
      i.strvalue_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.strvalue_value.capacity ());
    }

    // intvalue
    //
    {
      ::int64_t const& v =
        o.intvalue;

      bool is_null (false);
      mysql::value_traits<
          ::int64_t,
          mysql::id_longlong >::set_image (
        i.intvalue_value, is_null, v);
      i.intvalue_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_DictEntry__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_DictEntry__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // parent
    //
    {
      ::taxi::ID& v =
        o.parent;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.parent_value,
        i.parent_null);
    }

    // tag
    //
    {
      ::taxi::DictTag::type& v =
        o.tag;

      mysql::value_traits<
          ::taxi::DictTag::type,
          mysql::id_ulong >::set_value (
        v,
        i.tag_value,
        i.tag_null);
    }

    // idx
    //
    {
      ::taxi::NUMBER32& v =
        o.idx;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.idx_value,
        i.idx_null);
    }

    // strvalue
    //
    {
      ::taxi::STR& v =
        o.strvalue;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.strvalue_value,
        i.strvalue_size,
        i.strvalue_null);
    }

    // intvalue
    //
    {
      ::int64_t& v =
        o.intvalue;

      mysql::value_traits<
          ::int64_t,
          mysql::id_longlong >::set_value (
        v,
        i.intvalue_value,
        i.intvalue_null);
    }

    // __isset
    //
    {
      ::taxi::_DictEntry__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_DictEntry__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::DictEntry, id_mysql >::persist_statement[] =
  "INSERT INTO `DictEntry` "
  "(`id`, "
  "`parent`, "
  "`tag`, "
  "`idx`, "
  "`strvalue`, "
  "`intvalue`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::DictEntry, id_mysql >::find_statement[] =
  "SELECT "
  "`DictEntry`.`id`, "
  "`DictEntry`.`parent`, "
  "`DictEntry`.`tag`, "
  "`DictEntry`.`idx`, "
  "`DictEntry`.`strvalue`, "
  "`DictEntry`.`intvalue`, "
  "`DictEntry`.`isset` "
  "FROM `DictEntry` "
  "WHERE `DictEntry`.`id`=?";

  const char access::object_traits_impl< ::taxi::DictEntry, id_mysql >::update_statement[] =
  "UPDATE `DictEntry` "
  "SET "
  "`parent`=?, "
  "`tag`=?, "
  "`idx`=?, "
  "`strvalue`=?, "
  "`intvalue`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::DictEntry, id_mysql >::erase_statement[] =
  "DELETE FROM `DictEntry` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::DictEntry, id_mysql >::query_statement[] =
  "SELECT "
  "`DictEntry`.`id`, "
  "`DictEntry`.`parent`, "
  "`DictEntry`.`tag`, "
  "`DictEntry`.`idx`, "
  "`DictEntry`.`strvalue`, "
  "`DictEntry`.`intvalue`, "
  "`DictEntry`.`isset` "
  "FROM `DictEntry`";

  const char access::object_traits_impl< ::taxi::DictEntry, id_mysql >::erase_query_statement[] =
  "DELETE FROM `DictEntry`";

  const char access::object_traits_impl< ::taxi::DictEntry, id_mysql >::table_name[] =
  "`DictEntry`";

  void access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::DictEntry, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::DictEntry, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::DictEntry, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // PassengerLimit
  //

  bool access::composite_value_traits< ::taxi::PassengerLimit, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // tripcount
    //
    t[1UL] = 0;

    // minutescount
    //
    t[2UL] = 0;

    // moneycount
    //
    t[3UL] = 0;

    // __isset
    //
    if (t[4UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::PassengerLimit, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // id
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
    n++;

    // tripcount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.tripcount_value;
    b[n].is_null = &i.tripcount_null;
    n++;

    // minutescount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.minutescount_value;
    b[n].is_null = &i.minutescount_null;
    n++;

    // moneycount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.moneycount_value;
    b[n].is_null = &i.moneycount_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  bool access::composite_value_traits< ::taxi::PassengerLimit, id_mysql >::
  init (image_type& i,
        const value_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // tripcount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.tripcount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.tripcount_value, is_null, v);
      i.tripcount_null = is_null;
    }

    // minutescount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.minutescount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.minutescount_value, is_null, v);
      i.minutescount_null = is_null;
    }

    // moneycount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.moneycount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.moneycount_value, is_null, v);
      i.moneycount_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_PassengerLimit__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_PassengerLimit__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::PassengerLimit, id_mysql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // tripcount
    //
    {
      ::taxi::NUMBER32& v =
        o.tripcount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.tripcount_value,
        i.tripcount_null);
    }

    // minutescount
    //
    {
      ::taxi::NUMBER32& v =
        o.minutescount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.minutescount_value,
        i.minutescount_null);
    }

    // moneycount
    //
    {
      ::taxi::NUMBER32& v =
        o.moneycount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.moneycount_value,
        i.moneycount_null);
    }

    // __isset
    //
    {
      ::taxi::_PassengerLimit__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_PassengerLimit__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  // Payload
  //

  bool access::composite_value_traits< ::taxi::Payload, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // passengercount
    //
    t[0UL] = 0;

    // baggagecount
    //
    t[1UL] = 0;

    // baggageweight
    //
    t[2UL] = 0;

    // baggagewidth
    //
    t[3UL] = 0;

    // baggageheight
    //
    t[4UL] = 0;

    // papercount
    //
    t[5UL] = 0;

    // stopcount
    //
    t[6UL] = 0;

    // __isset
    //
    if (t[7UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::Payload, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // passengercount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.passengercount_value;
    b[n].is_null = &i.passengercount_null;
    n++;

    // baggagecount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.baggagecount_value;
    b[n].is_null = &i.baggagecount_null;
    n++;

    // baggageweight
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.baggageweight_value;
    b[n].is_null = &i.baggageweight_null;
    n++;

    // baggagewidth
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.baggagewidth_value;
    b[n].is_null = &i.baggagewidth_null;
    n++;

    // baggageheight
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.baggageheight_value;
    b[n].is_null = &i.baggageheight_null;
    n++;

    // papercount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.papercount_value;
    b[n].is_null = &i.papercount_null;
    n++;

    // stopcount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.stopcount_value;
    b[n].is_null = &i.stopcount_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  bool access::composite_value_traits< ::taxi::Payload, id_mysql >::
  init (image_type& i,
        const value_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // passengercount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.passengercount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.passengercount_value, is_null, v);
      i.passengercount_null = is_null;
    }

    // baggagecount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.baggagecount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.baggagecount_value, is_null, v);
      i.baggagecount_null = is_null;
    }

    // baggageweight
    //
    {
      ::taxi::NUMBER32 const& v =
        o.baggageweight;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.baggageweight_value, is_null, v);
      i.baggageweight_null = is_null;
    }

    // baggagewidth
    //
    {
      ::taxi::NUMBER32 const& v =
        o.baggagewidth;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.baggagewidth_value, is_null, v);
      i.baggagewidth_null = is_null;
    }

    // baggageheight
    //
    {
      ::taxi::NUMBER32 const& v =
        o.baggageheight;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.baggageheight_value, is_null, v);
      i.baggageheight_null = is_null;
    }

    // papercount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.papercount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.papercount_value, is_null, v);
      i.papercount_null = is_null;
    }

    // stopcount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.stopcount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.stopcount_value, is_null, v);
      i.stopcount_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_Payload__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Payload__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::Payload, id_mysql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // passengercount
    //
    {
      ::taxi::NUMBER32& v =
        o.passengercount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.passengercount_value,
        i.passengercount_null);
    }

    // baggagecount
    //
    {
      ::taxi::NUMBER32& v =
        o.baggagecount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.baggagecount_value,
        i.baggagecount_null);
    }

    // baggageweight
    //
    {
      ::taxi::NUMBER32& v =
        o.baggageweight;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.baggageweight_value,
        i.baggageweight_null);
    }

    // baggagewidth
    //
    {
      ::taxi::NUMBER32& v =
        o.baggagewidth;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.baggagewidth_value,
        i.baggagewidth_null);
    }

    // baggageheight
    //
    {
      ::taxi::NUMBER32& v =
        o.baggageheight;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.baggageheight_value,
        i.baggageheight_null);
    }

    // papercount
    //
    {
      ::taxi::NUMBER32& v =
        o.papercount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.papercount_value,
        i.papercount_null);
    }

    // stopcount
    //
    {
      ::taxi::NUMBER32& v =
        o.stopcount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.stopcount_value,
        i.stopcount_null);
    }

    // __isset
    //
    {
      ::taxi::_Payload__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Payload__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  // PassengerUsage
  //

  bool access::composite_value_traits< ::taxi::PassengerUsage, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // tripcount
    //
    t[1UL] = 0;

    // minutescount
    //
    t[2UL] = 0;

    // moneycount
    //
    t[3UL] = 0;

    // payload
    //
    if (composite_value_traits< ::taxi::Payload, id_mysql >::grow (
          i.payload_value, t + 4UL))
      grew = true;

    // __isset
    //
    if (t[12UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::PassengerUsage, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // id
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
    n++;

    // tripcount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.tripcount_value;
    b[n].is_null = &i.tripcount_null;
    n++;

    // minutescount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.minutescount_value;
    b[n].is_null = &i.minutescount_null;
    n++;

    // moneycount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.moneycount_value;
    b[n].is_null = &i.moneycount_null;
    n++;

    // payload
    //
    composite_value_traits< ::taxi::Payload, id_mysql >::bind (
      b + n, i.payload_value, sk);
    n += 8UL;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  bool access::composite_value_traits< ::taxi::PassengerUsage, id_mysql >::
  init (image_type& i,
        const value_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // tripcount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.tripcount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.tripcount_value, is_null, v);
      i.tripcount_null = is_null;
    }

    // minutescount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.minutescount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.minutescount_value, is_null, v);
      i.minutescount_null = is_null;
    }

    // moneycount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.moneycount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.moneycount_value, is_null, v);
      i.moneycount_null = is_null;
    }

    // payload
    //
    {
      ::taxi::Payload const& v =
        o.payload;

      if (composite_value_traits< ::taxi::Payload, id_mysql >::init (
            i.payload_value,
            v,
            sk))
        grew = true;
    }

    // __isset
    //
    {
      ::taxi::_PassengerUsage__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_PassengerUsage__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::PassengerUsage, id_mysql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // tripcount
    //
    {
      ::taxi::NUMBER32& v =
        o.tripcount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.tripcount_value,
        i.tripcount_null);
    }

    // minutescount
    //
    {
      ::taxi::NUMBER32& v =
        o.minutescount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.minutescount_value,
        i.minutescount_null);
    }

    // moneycount
    //
    {
      ::taxi::NUMBER32& v =
        o.moneycount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.moneycount_value,
        i.moneycount_null);
    }

    // payload
    //
    {
      ::taxi::Payload& v =
        o.payload;

      composite_value_traits< ::taxi::Payload, id_mysql >::init (
        v,
        i.payload_value,
        db);
    }

    // __isset
    //
    {
      ::taxi::_PassengerUsage__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_PassengerUsage__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  // UserDevice
  //

  bool access::composite_value_traits< ::taxi::UserDevice, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // devicetype
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.devicetype_value, i.devicetype_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // isactive
    //
    t[1UL] = 0;

    // model
    //
    if (t[2UL])
    {
      i.model_value.capacity (i.model_size);
      grew = true;
    }

    // imei
    //
    if (t[3UL])
    {
      i.imei_value.capacity (i.imei_size);
      grew = true;
    }

    // line1
    //
    if (t[4UL])
    {
      i.line1_value.capacity (i.line1_size);
      grew = true;
    }

    // line2
    //
    if (t[5UL])
    {
      i.line2_value.capacity (i.line2_size);
      grew = true;
    }

    // hasGSMorCDMA
    //
    t[6UL] = 0;

    // hasGPS
    //
    t[7UL] = 0;

    // isGPS
    //
    t[8UL] = 0;

    // __isset
    //
    if (t[9UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::UserDevice, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // devicetype
    //
    mysql::enum_traits::bind (b[n],
                              i.devicetype_value,
                              i.devicetype_size,
                              &i.devicetype_null);
    n++;

    // isactive
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.isactive_value;
    b[n].is_null = &i.isactive_null;
    n++;

    // model
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.model_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.model_value.capacity ());
    b[n].length = &i.model_size;
    b[n].is_null = &i.model_null;
    n++;

    // imei
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.imei_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.imei_value.capacity ());
    b[n].length = &i.imei_size;
    b[n].is_null = &i.imei_null;
    n++;

    // line1
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.line1_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.line1_value.capacity ());
    b[n].length = &i.line1_size;
    b[n].is_null = &i.line1_null;
    n++;

    // line2
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.line2_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.line2_value.capacity ());
    b[n].length = &i.line2_size;
    b[n].is_null = &i.line2_null;
    n++;

    // hasGSMorCDMA
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.hasGSMorCDMA_value;
    b[n].is_null = &i.hasGSMorCDMA_null;
    n++;

    // hasGPS
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.hasGPS_value;
    b[n].is_null = &i.hasGPS_null;
    n++;

    // isGPS
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.isGPS_value;
    b[n].is_null = &i.isGPS_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  bool access::composite_value_traits< ::taxi::UserDevice, id_mysql >::
  init (image_type& i,
        const value_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // devicetype
    //
    {
      ::taxi::DeviceType::type const& v =
        o.devicetype;

      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.devicetype_value,
            i.devicetype_size,
            is_null,
            v))
        grew = true;

      i.devicetype_null = is_null;
    }

    // isactive
    //
    {
      bool const& v =
        o.isactive;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.isactive_value, is_null, v);
      i.isactive_null = is_null;
    }

    // model
    //
    {
      ::taxi::STR const& v =
        o.model;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.model_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.model_value,
        size,
        is_null,
        v);
      i.model_null = is_null;
      i.model_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.model_value.capacity ());
    }

    // imei
    //
    {
      ::taxi::STR const& v =
        o.imei;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.imei_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.imei_value,
        size,
        is_null,
        v);
      i.imei_null = is_null;
      i.imei_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.imei_value.capacity ());
    }

    // line1
    //
    {
      ::taxi::STR const& v =
        o.line1;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.line1_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.line1_value,
        size,
        is_null,
        v);
      i.line1_null = is_null;
      i.line1_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.line1_value.capacity ());
    }

    // line2
    //
    {
      ::taxi::STR const& v =
        o.line2;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.line2_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.line2_value,
        size,
        is_null,
        v);
      i.line2_null = is_null;
      i.line2_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.line2_value.capacity ());
    }

    // hasGSMorCDMA
    //
    {
      bool const& v =
        o.hasGSMorCDMA;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.hasGSMorCDMA_value, is_null, v);
      i.hasGSMorCDMA_null = is_null;
    }

    // hasGPS
    //
    {
      bool const& v =
        o.hasGPS;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.hasGPS_value, is_null, v);
      i.hasGPS_null = is_null;
    }

    // isGPS
    //
    {
      bool const& v =
        o.isGPS;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.isGPS_value, is_null, v);
      i.isGPS_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_UserDevice__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_UserDevice__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::UserDevice, id_mysql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // devicetype
    //
    {
      ::taxi::DeviceType::type& v =
        o.devicetype;

      mysql::enum_traits::set_value (
        v,
        i.devicetype_value,
        i.devicetype_size,
        i.devicetype_null);
    }

    // isactive
    //
    {
      bool& v =
        o.isactive;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.isactive_value,
        i.isactive_null);
    }

    // model
    //
    {
      ::taxi::STR& v =
        o.model;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.model_value,
        i.model_size,
        i.model_null);
    }

    // imei
    //
    {
      ::taxi::STR& v =
        o.imei;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.imei_value,
        i.imei_size,
        i.imei_null);
    }

    // line1
    //
    {
      ::taxi::STR& v =
        o.line1;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.line1_value,
        i.line1_size,
        i.line1_null);
    }

    // line2
    //
    {
      ::taxi::STR& v =
        o.line2;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.line2_value,
        i.line2_size,
        i.line2_null);
    }

    // hasGSMorCDMA
    //
    {
      bool& v =
        o.hasGSMorCDMA;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.hasGSMorCDMA_value,
        i.hasGSMorCDMA_null);
    }

    // hasGPS
    //
    {
      bool& v =
        o.hasGPS;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.hasGPS_value,
        i.hasGPS_null);
    }

    // isGPS
    //
    {
      bool& v =
        o.isGPS;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.isGPS_value,
        i.isGPS_null);
    }

    // __isset
    //
    {
      ::taxi::_UserDevice__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_UserDevice__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  // Credentials
  //

  bool access::composite_value_traits< ::taxi::Credentials, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // phone
    //
    if (t[0UL])
    {
      i.phone_value.capacity (i.phone_size);
      grew = true;
    }

    // personrole
    //
    if (t[1UL])
    {
      if (mysql::enum_traits::grow (i.personrole_value, i.personrole_size))
        grew = true;
      else
        t[1UL] = 0;
    }

    // token
    //
    if (t[2UL])
    {
      i.token_value.capacity (i.token_size);
      grew = true;
    }

    // password
    //
    if (t[3UL])
    {
      i.password_value.capacity (i.password_size);
      grew = true;
    }

    // islogged
    //
    t[4UL] = 0;

    // timelogon
    //
    t[5UL] = 0;

    // __isset
    //
    if (t[6UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::Credentials, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // phone
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.phone_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.phone_value.capacity ());
    b[n].length = &i.phone_size;
    b[n].is_null = &i.phone_null;
    n++;

    // personrole
    //
    mysql::enum_traits::bind (b[n],
                              i.personrole_value,
                              i.personrole_size,
                              &i.personrole_null);
    n++;

    // token
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.token_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.token_value.capacity ());
    b[n].length = &i.token_size;
    b[n].is_null = &i.token_null;
    n++;

    // password
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.password_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.password_value.capacity ());
    b[n].length = &i.password_size;
    b[n].is_null = &i.password_null;
    n++;

    // islogged
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.islogged_value;
    b[n].is_null = &i.islogged_null;
    n++;

    // timelogon
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.timelogon_value;
    b[n].is_null = &i.timelogon_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  bool access::composite_value_traits< ::taxi::Credentials, id_mysql >::
  init (image_type& i,
        const value_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // phone
    //
    {
      ::taxi::STR const& v =
        o.phone;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.phone_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.phone_value,
        size,
        is_null,
        v);
      i.phone_null = is_null;
      i.phone_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.phone_value.capacity ());
    }

    // personrole
    //
    {
      ::taxi::PersonRole::type const& v =
        o.personrole;

      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.personrole_value,
            i.personrole_size,
            is_null,
            v))
        grew = true;

      i.personrole_null = is_null;
    }

    // token
    //
    {
      ::taxi::STR const& v =
        o.token;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.token_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.token_value,
        size,
        is_null,
        v);
      i.token_null = is_null;
      i.token_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.token_value.capacity ());
    }

    // password
    //
    {
      ::taxi::STR const& v =
        o.password;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.password_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.password_value,
        size,
        is_null,
        v);
      i.password_null = is_null;
      i.password_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.password_value.capacity ());
    }

    // islogged
    //
    {
      bool const& v =
        o.islogged;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.islogged_value, is_null, v);
      i.islogged_null = is_null;
    }

    // timelogon
    //
    {
      ::taxi::DATE const& v =
        o.timelogon;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.timelogon_value, is_null, v);
      i.timelogon_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_Credentials__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Credentials__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::Credentials, id_mysql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // phone
    //
    {
      ::taxi::STR& v =
        o.phone;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.phone_value,
        i.phone_size,
        i.phone_null);
    }

    // personrole
    //
    {
      ::taxi::PersonRole::type& v =
        o.personrole;

      mysql::enum_traits::set_value (
        v,
        i.personrole_value,
        i.personrole_size,
        i.personrole_null);
    }

    // token
    //
    {
      ::taxi::STR& v =
        o.token;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.token_value,
        i.token_size,
        i.token_null);
    }

    // password
    //
    {
      ::taxi::STR& v =
        o.password;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.password_value,
        i.password_size,
        i.password_null);
    }

    // islogged
    //
    {
      bool& v =
        o.islogged;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.islogged_value,
        i.islogged_null);
    }

    // timelogon
    //
    {
      ::taxi::DATE& v =
        o.timelogon;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.timelogon_value,
        i.timelogon_null);
    }

    // __isset
    //
    {
      ::taxi::_Credentials__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Credentials__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  // Person
  //

  // userdevice
  //

  void access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_mysql >::bind (
      b + n, d.value_value, sk);
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< value_type, id_mysql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_mysql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_mysql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::userdevice_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  bool access::composite_value_traits< ::taxi::Person, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // credentials
    //
    if (composite_value_traits< ::taxi::Credentials, id_mysql >::grow (
          i.credentials_value, t + 0UL))
      grew = true;

    // tag
    //
    t[7UL] = 0;

    // firstname
    //
    if (t[8UL])
    {
      i.firstname_value.capacity (i.firstname_size);
      grew = true;
    }

    // lastname
    //
    if (t[9UL])
    {
      i.lastname_value.capacity (i.lastname_size);
      grew = true;
    }

    // middlename
    //
    if (t[10UL])
    {
      i.middlename_value.capacity (i.middlename_size);
      grew = true;
    }

    // prefix
    //
    if (t[11UL])
    {
      i.prefix_value.capacity (i.prefix_size);
      grew = true;
    }

    // birthdate
    //
    t[12UL] = 0;

    // deparment
    //
    if (t[13UL])
    {
      i.deparment_value.capacity (i.deparment_size);
      grew = true;
    }

    // position
    //
    if (t[14UL])
    {
      i.position_value.capacity (i.position_size);
      grew = true;
    }

    // note
    //
    if (t[15UL])
    {
      i.note_value.capacity (i.note_size);
      grew = true;
    }

    // phone1
    //
    if (t[16UL])
    {
      i.phone1_value.capacity (i.phone1_size);
      grew = true;
    }

    // phone2
    //
    if (t[17UL])
    {
      i.phone2_value.capacity (i.phone2_size);
      grew = true;
    }

    // fax
    //
    if (t[18UL])
    {
      i.fax_value.capacity (i.fax_size);
      grew = true;
    }

    // email
    //
    if (t[19UL])
    {
      i.email_value.capacity (i.email_size);
      grew = true;
    }

    // photo
    //
    if (t[20UL])
    {
      i.photo_value.capacity (i.photo_size);
      grew = true;
    }

    // __isset
    //
    if (t[21UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // credentials
    //
    composite_value_traits< ::taxi::Credentials, id_mysql >::bind (
      b + n, i.credentials_value, sk);
    n += 7UL;

    // tag
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.tag_value;
    b[n].is_null = &i.tag_null;
    n++;

    // firstname
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.firstname_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.firstname_value.capacity ());
    b[n].length = &i.firstname_size;
    b[n].is_null = &i.firstname_null;
    n++;

    // lastname
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.lastname_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.lastname_value.capacity ());
    b[n].length = &i.lastname_size;
    b[n].is_null = &i.lastname_null;
    n++;

    // middlename
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.middlename_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.middlename_value.capacity ());
    b[n].length = &i.middlename_size;
    b[n].is_null = &i.middlename_null;
    n++;

    // prefix
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.prefix_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.prefix_value.capacity ());
    b[n].length = &i.prefix_size;
    b[n].is_null = &i.prefix_null;
    n++;

    // birthdate
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.birthdate_value;
    b[n].is_null = &i.birthdate_null;
    n++;

    // deparment
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.deparment_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.deparment_value.capacity ());
    b[n].length = &i.deparment_size;
    b[n].is_null = &i.deparment_null;
    n++;

    // position
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.position_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.position_value.capacity ());
    b[n].length = &i.position_size;
    b[n].is_null = &i.position_null;
    n++;

    // note
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.note_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.note_value.capacity ());
    b[n].length = &i.note_size;
    b[n].is_null = &i.note_null;
    n++;

    // phone1
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.phone1_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.phone1_value.capacity ());
    b[n].length = &i.phone1_size;
    b[n].is_null = &i.phone1_null;
    n++;

    // phone2
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.phone2_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.phone2_value.capacity ());
    b[n].length = &i.phone2_size;
    b[n].is_null = &i.phone2_null;
    n++;

    // fax
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.fax_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.fax_value.capacity ());
    b[n].length = &i.fax_size;
    b[n].is_null = &i.fax_null;
    n++;

    // email
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.email_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.email_value.capacity ());
    b[n].length = &i.email_size;
    b[n].is_null = &i.email_null;
    n++;

    // photo
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.photo_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.photo_value.capacity ());
    b[n].length = &i.photo_size;
    b[n].is_null = &i.photo_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  bool access::composite_value_traits< ::taxi::Person, id_mysql >::
  init (image_type& i,
        const value_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // credentials
    //
    {
      ::taxi::Credentials const& v =
        o.credentials;

      if (composite_value_traits< ::taxi::Credentials, id_mysql >::init (
            i.credentials_value,
            v,
            sk))
        grew = true;
    }

    // tag
    //
    {
      ::taxi::TAG const& v =
        o.tag;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::TAG,
          mysql::id_long >::set_image (
        i.tag_value, is_null, v);
      i.tag_null = is_null;
    }

    // firstname
    //
    {
      ::taxi::STR const& v =
        o.firstname;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.firstname_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.firstname_value,
        size,
        is_null,
        v);
      i.firstname_null = is_null;
      i.firstname_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.firstname_value.capacity ());
    }

    // lastname
    //
    {
      ::taxi::STR const& v =
        o.lastname;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.lastname_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.lastname_value,
        size,
        is_null,
        v);
      i.lastname_null = is_null;
      i.lastname_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.lastname_value.capacity ());
    }

    // middlename
    //
    {
      ::taxi::STR const& v =
        o.middlename;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.middlename_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.middlename_value,
        size,
        is_null,
        v);
      i.middlename_null = is_null;
      i.middlename_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.middlename_value.capacity ());
    }

    // prefix
    //
    {
      ::taxi::STR const& v =
        o.prefix;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.prefix_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.prefix_value,
        size,
        is_null,
        v);
      i.prefix_null = is_null;
      i.prefix_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.prefix_value.capacity ());
    }

    // birthdate
    //
    {
      ::taxi::DATE const& v =
        o.birthdate;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.birthdate_value, is_null, v);
      i.birthdate_null = is_null;
    }

    // deparment
    //
    {
      ::taxi::STR const& v =
        o.deparment;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.deparment_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.deparment_value,
        size,
        is_null,
        v);
      i.deparment_null = is_null;
      i.deparment_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.deparment_value.capacity ());
    }

    // position
    //
    {
      ::taxi::STR const& v =
        o.position;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.position_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.position_value,
        size,
        is_null,
        v);
      i.position_null = is_null;
      i.position_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.position_value.capacity ());
    }

    // note
    //
    {
      ::taxi::STR const& v =
        o.note;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.note_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.note_value,
        size,
        is_null,
        v);
      i.note_null = is_null;
      i.note_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.note_value.capacity ());
    }

    // phone1
    //
    {
      ::taxi::TEL const& v =
        o.phone1;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.phone1_value.capacity ());
      mysql::value_traits<
          ::taxi::TEL,
          mysql::id_string >::set_image (
        i.phone1_value,
        size,
        is_null,
        v);
      i.phone1_null = is_null;
      i.phone1_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.phone1_value.capacity ());
    }

    // phone2
    //
    {
      ::taxi::TEL const& v =
        o.phone2;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.phone2_value.capacity ());
      mysql::value_traits<
          ::taxi::TEL,
          mysql::id_string >::set_image (
        i.phone2_value,
        size,
        is_null,
        v);
      i.phone2_null = is_null;
      i.phone2_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.phone2_value.capacity ());
    }

    // fax
    //
    {
      ::taxi::FAX const& v =
        o.fax;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.fax_value.capacity ());
      mysql::value_traits<
          ::taxi::FAX,
          mysql::id_string >::set_image (
        i.fax_value,
        size,
        is_null,
        v);
      i.fax_null = is_null;
      i.fax_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.fax_value.capacity ());
    }

    // email
    //
    {
      ::taxi::MAILTO const& v =
        o.email;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.email_value.capacity ());
      mysql::value_traits<
          ::taxi::MAILTO,
          mysql::id_string >::set_image (
        i.email_value,
        size,
        is_null,
        v);
      i.email_null = is_null;
      i.email_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.email_value.capacity ());
    }

    // photo
    //
    {
      ::taxi::LINK const& v =
        o.photo;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.photo_value.capacity ());
      mysql::value_traits<
          ::taxi::LINK,
          mysql::id_string >::set_image (
        i.photo_value,
        size,
        is_null,
        v);
      i.photo_null = is_null;
      i.photo_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.photo_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_Person__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Person__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::Person, id_mysql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // credentials
    //
    {
      ::taxi::Credentials& v =
        o.credentials;

      composite_value_traits< ::taxi::Credentials, id_mysql >::init (
        v,
        i.credentials_value,
        db);
    }

    // tag
    //
    {
      ::taxi::TAG& v =
        o.tag;

      mysql::value_traits<
          ::taxi::TAG,
          mysql::id_long >::set_value (
        v,
        i.tag_value,
        i.tag_null);
    }

    // firstname
    //
    {
      ::taxi::STR& v =
        o.firstname;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.firstname_value,
        i.firstname_size,
        i.firstname_null);
    }

    // lastname
    //
    {
      ::taxi::STR& v =
        o.lastname;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.lastname_value,
        i.lastname_size,
        i.lastname_null);
    }

    // middlename
    //
    {
      ::taxi::STR& v =
        o.middlename;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.middlename_value,
        i.middlename_size,
        i.middlename_null);
    }

    // prefix
    //
    {
      ::taxi::STR& v =
        o.prefix;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.prefix_value,
        i.prefix_size,
        i.prefix_null);
    }

    // birthdate
    //
    {
      ::taxi::DATE& v =
        o.birthdate;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.birthdate_value,
        i.birthdate_null);
    }

    // deparment
    //
    {
      ::taxi::STR& v =
        o.deparment;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.deparment_value,
        i.deparment_size,
        i.deparment_null);
    }

    // position
    //
    {
      ::taxi::STR& v =
        o.position;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.position_value,
        i.position_size,
        i.position_null);
    }

    // note
    //
    {
      ::taxi::STR& v =
        o.note;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.note_value,
        i.note_size,
        i.note_null);
    }

    // phone1
    //
    {
      ::taxi::TEL& v =
        o.phone1;

      mysql::value_traits<
          ::taxi::TEL,
          mysql::id_string >::set_value (
        v,
        i.phone1_value,
        i.phone1_size,
        i.phone1_null);
    }

    // phone2
    //
    {
      ::taxi::TEL& v =
        o.phone2;

      mysql::value_traits<
          ::taxi::TEL,
          mysql::id_string >::set_value (
        v,
        i.phone2_value,
        i.phone2_size,
        i.phone2_null);
    }

    // fax
    //
    {
      ::taxi::FAX& v =
        o.fax;

      mysql::value_traits<
          ::taxi::FAX,
          mysql::id_string >::set_value (
        v,
        i.fax_value,
        i.fax_size,
        i.fax_null);
    }

    // email
    //
    {
      ::taxi::MAILTO& v =
        o.email;

      mysql::value_traits<
          ::taxi::MAILTO,
          mysql::id_string >::set_value (
        v,
        i.email_value,
        i.email_size,
        i.email_null);
    }

    // photo
    //
    {
      ::taxi::LINK& v =
        o.photo;

      mysql::value_traits<
          ::taxi::LINK,
          mysql::id_string >::set_value (
        v,
        i.photo_value,
        i.photo_size,
        i.photo_null);
    }

    // __isset
    //
    {
      ::taxi::_Person__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Person__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  // Bank
  //

  struct access::object_traits_impl< ::taxi::Bank, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::Bank, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Bank, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Bank, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // bik
    //
    if (t[1UL])
    {
      i.bik_value.capacity (i.bik_size);
      grew = true;
    }

    // name
    //
    if (t[2UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // __isset
    //
    if (t[3UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Bank, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // bik
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.bik_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.bik_value.capacity ());
    b[n].length = &i.bik_size;
    b[n].is_null = &i.bik_null;
    n++;

    // name
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.name_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.name_value.capacity ());
    b[n].length = &i.name_size;
    b[n].is_null = &i.name_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Bank, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Bank, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // bik
    //
    {
      ::taxi::STR const& v =
        o.bik;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.bik_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.bik_value,
        size,
        is_null,
        v);
      i.bik_null = is_null;
      i.bik_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.bik_value.capacity ());
    }

    // name
    //
    {
      ::taxi::STR const& v =
        o.name;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.name_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.name_value,
        size,
        is_null,
        v);
      i.name_null = is_null;
      i.name_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.name_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_Bank__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Bank__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Bank, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // bik
    //
    {
      ::taxi::STR& v =
        o.bik;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.bik_value,
        i.bik_size,
        i.bik_null);
    }

    // name
    //
    {
      ::taxi::STR& v =
        o.name;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // __isset
    //
    {
      ::taxi::_Bank__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Bank__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Bank, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Bank, id_mysql >::persist_statement[] =
  "INSERT INTO `Bank` "
  "(`id`, "
  "`bik`, "
  "`name`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Bank, id_mysql >::find_statement[] =
  "SELECT "
  "`Bank`.`id`, "
  "`Bank`.`bik`, "
  "`Bank`.`name`, "
  "`Bank`.`isset` "
  "FROM `Bank` "
  "WHERE `Bank`.`id`=?";

  const char access::object_traits_impl< ::taxi::Bank, id_mysql >::update_statement[] =
  "UPDATE `Bank` "
  "SET "
  "`bik`=?, "
  "`name`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Bank, id_mysql >::erase_statement[] =
  "DELETE FROM `Bank` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Bank, id_mysql >::query_statement[] =
  "SELECT "
  "`Bank`.`id`, "
  "`Bank`.`bik`, "
  "`Bank`.`name`, "
  "`Bank`.`isset` "
  "FROM `Bank`";

  const char access::object_traits_impl< ::taxi::Bank, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Bank`";

  const char access::object_traits_impl< ::taxi::Bank, id_mysql >::table_name[] =
  "`Bank`";

  void access::object_traits_impl< ::taxi::Bank, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Bank, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Bank, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Bank, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Bank, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Bank, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Bank, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Bank, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::Bank, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Bank, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Bank, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // GeoLocation
  //

  bool access::composite_value_traits< ::taxi::GeoLocation, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // latitude
    //
    t[0UL] = 0;

    // longitude
    //
    t[1UL] = 0;

    // __isset
    //
    if (t[2UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::GeoLocation, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // latitude
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.latitude_value;
    b[n].is_null = &i.latitude_null;
    n++;

    // longitude
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.longitude_value;
    b[n].is_null = &i.longitude_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  bool access::composite_value_traits< ::taxi::GeoLocation, id_mysql >::
  init (image_type& i,
        const value_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // latitude
    //
    {
      ::taxi::GEO const& v =
        o.latitude;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::GEO,
          mysql::id_double >::set_image (
        i.latitude_value, is_null, v);
      i.latitude_null = is_null;
    }

    // longitude
    //
    {
      ::taxi::GEO const& v =
        o.longitude;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::GEO,
          mysql::id_double >::set_image (
        i.longitude_value, is_null, v);
      i.longitude_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_GeoLocation__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_GeoLocation__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::GeoLocation, id_mysql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // latitude
    //
    {
      ::taxi::GEO& v =
        o.latitude;

      mysql::value_traits<
          ::taxi::GEO,
          mysql::id_double >::set_value (
        v,
        i.latitude_value,
        i.latitude_null);
    }

    // longitude
    //
    {
      ::taxi::GEO& v =
        o.longitude;

      mysql::value_traits<
          ::taxi::GEO,
          mysql::id_double >::set_value (
        v,
        i.longitude_value,
        i.longitude_null);
    }

    // __isset
    //
    {
      ::taxi::_GeoLocation__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_GeoLocation__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  // Location
  //

  bool access::composite_value_traits< ::taxi::Location, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // location
    //
    if (composite_value_traits< ::taxi::GeoLocation, id_mysql >::grow (
          i.location_value, t + 0UL))
      grew = true;

    // name
    //
    if (t[3UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // city
    //
    if (t[4UL])
    {
      i.city_value.capacity (i.city_size);
      grew = true;
    }

    // address
    //
    if (t[5UL])
    {
      i.address_value.capacity (i.address_size);
      grew = true;
    }

    // __isset
    //
    if (t[6UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::Location, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // location
    //
    composite_value_traits< ::taxi::GeoLocation, id_mysql >::bind (
      b + n, i.location_value, sk);
    n += 3UL;

    // name
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.name_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.name_value.capacity ());
    b[n].length = &i.name_size;
    b[n].is_null = &i.name_null;
    n++;

    // city
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.city_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.city_value.capacity ());
    b[n].length = &i.city_size;
    b[n].is_null = &i.city_null;
    n++;

    // address
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.address_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.address_value.capacity ());
    b[n].length = &i.address_size;
    b[n].is_null = &i.address_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  bool access::composite_value_traits< ::taxi::Location, id_mysql >::
  init (image_type& i,
        const value_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // location
    //
    {
      ::taxi::GeoLocation const& v =
        o.location;

      if (composite_value_traits< ::taxi::GeoLocation, id_mysql >::init (
            i.location_value,
            v,
            sk))
        grew = true;
    }

    // name
    //
    {
      ::taxi::STR const& v =
        o.name;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.name_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.name_value,
        size,
        is_null,
        v);
      i.name_null = is_null;
      i.name_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.name_value.capacity ());
    }

    // city
    //
    {
      ::taxi::STR const& v =
        o.city;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.city_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.city_value,
        size,
        is_null,
        v);
      i.city_null = is_null;
      i.city_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.city_value.capacity ());
    }

    // address
    //
    {
      ::taxi::STR const& v =
        o.address;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.address_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.address_value,
        size,
        is_null,
        v);
      i.address_null = is_null;
      i.address_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.address_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_Location__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Location__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::Location, id_mysql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // location
    //
    {
      ::taxi::GeoLocation& v =
        o.location;

      composite_value_traits< ::taxi::GeoLocation, id_mysql >::init (
        v,
        i.location_value,
        db);
    }

    // name
    //
    {
      ::taxi::STR& v =
        o.name;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // city
    //
    {
      ::taxi::STR& v =
        o.city;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.city_value,
        i.city_size,
        i.city_null);
    }

    // address
    //
    {
      ::taxi::STR& v =
        o.address;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.address_value,
        i.address_size,
        i.address_null);
    }

    // __isset
    //
    {
      ::taxi::_Location__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Location__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  // Org
  //

  struct access::object_traits_impl< ::taxi::Org, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< orgaddress_traits > orgaddress;
    mysql::container_statements_impl< employee_traits > employee;
    mysql::container_statements_impl< bank_traits > bank;
    mysql::container_statements_impl< orglocation_traits > orglocation;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : orgaddress (c, id),
      employee (c, id),
      bank (c, id),
      orglocation (c, id)
    {
    }
  };

  // orgaddress
  //

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Org_orgaddress`.`key`+0,' ',`Org_orgaddress`.`key`), "
  "`Org_orgaddress`.`value` "
  "FROM `Org_orgaddress` "
  "WHERE `Org_orgaddress`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  insert_statement[] =
  "INSERT INTO `Org_orgaddress` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  delete_statement[] =
  "DELETE FROM `Org_orgaddress` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = d.value_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      d.value_value.capacity ());
    b[n].length = &d.value_size;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    if (t[1UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.value_value.capacity ());
      mysql::value_traits<
          value_type,
          mysql::id_string >::set_image (
        i.value_value,
        size,
        is_null,
        v);
      i.value_null = is_null;
      i.value_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.value_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_string >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orgaddress_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // employee
  //

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Org_employee`.`key`+0,' ',`Org_employee`.`key`), "
  "`Org_employee`.`value_credentials_phone`, "
  "CONCAT(`Org_employee`.`value_credentials_personrole`+0,' ',`Org_employee`.`value_credentials_personrole`), "
  "`Org_employee`.`value_credentials_token`, "
  "`Org_employee`.`value_credentials_password`, "
  "`Org_employee`.`value_credentials_islogged`, "
  "`Org_employee`.`value_credentials_timelogon`, "
  "`Org_employee`.`value_credentials_isset`, "
  "`Org_employee`.`value_tag`, "
  "`Org_employee`.`value_firstname`, "
  "`Org_employee`.`value_lastname`, "
  "`Org_employee`.`value_middlename`, "
  "`Org_employee`.`value_prefix`, "
  "`Org_employee`.`value_birthdate`, "
  "`Org_employee`.`value_deparment`, "
  "`Org_employee`.`value_position`, "
  "`Org_employee`.`value_note`, "
  "`Org_employee`.`value_phone1`, "
  "`Org_employee`.`value_phone2`, "
  "`Org_employee`.`value_fax`, "
  "`Org_employee`.`value_email`, "
  "`Org_employee`.`value_photo`, "
  "`Org_employee`.`value_isset` "
  "FROM `Org_employee` "
  "WHERE `Org_employee`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  insert_statement[] =
  "INSERT INTO `Org_employee` "
  "(`object_id`, "
  "`key`, "
  "`value_credentials_phone`, "
  "`value_credentials_personrole`, "
  "`value_credentials_token`, "
  "`value_credentials_password`, "
  "`value_credentials_islogged`, "
  "`value_credentials_timelogon`, "
  "`value_credentials_isset`, "
  "`value_tag`, "
  "`value_firstname`, "
  "`value_lastname`, "
  "`value_middlename`, "
  "`value_prefix`, "
  "`value_birthdate`, "
  "`value_deparment`, "
  "`value_position`, "
  "`value_note`, "
  "`value_phone1`, "
  "`value_phone2`, "
  "`value_fax`, "
  "`value_email`, "
  "`value_photo`, "
  "`value_isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  delete_statement[] =
  "DELETE FROM `Org_employee` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    composite_value_traits< value_type, id_mysql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    if (composite_value_traits< value_type, id_mysql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_mysql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_mysql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::employee_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // bank
  //

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Org_bank`.`key`+0,' ',`Org_bank`.`key`), "
  "`Org_bank`.`value` "
  "FROM `Org_bank` "
  "WHERE `Org_bank`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  insert_statement[] =
  "INSERT INTO `Org_bank` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  delete_statement[] =
  "DELETE FROM `Org_bank` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::bank_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // orglocation
  //

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Org_orglocation`.`key`+0,' ',`Org_orglocation`.`key`), "
  "`Org_orglocation`.`value_location_latitude`, "
  "`Org_orglocation`.`value_location_longitude`, "
  "`Org_orglocation`.`value_location_isset`, "
  "`Org_orglocation`.`value_name`, "
  "`Org_orglocation`.`value_city`, "
  "`Org_orglocation`.`value_address`, "
  "`Org_orglocation`.`value_isset` "
  "FROM `Org_orglocation` "
  "WHERE `Org_orglocation`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  insert_statement[] =
  "INSERT INTO `Org_orglocation` "
  "(`object_id`, "
  "`key`, "
  "`value_location_latitude`, "
  "`value_location_longitude`, "
  "`value_location_isset`, "
  "`value_name`, "
  "`value_city`, "
  "`value_address`, "
  "`value_isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  delete_statement[] =
  "DELETE FROM `Org_orglocation` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    composite_value_traits< value_type, id_mysql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    if (composite_value_traits< value_type, id_mysql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_mysql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_mysql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::orglocation_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::Org, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Org, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Org, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // orgrole
    //
    if (t[1UL])
    {
      if (mysql::enum_traits::grow (i.orgrole_value, i.orgrole_size))
        grew = true;
      else
        t[1UL] = 0;
    }

    // orgtype
    //
    t[2UL] = 0;

    // start
    //
    t[3UL] = 0;

    // tag
    //
    t[4UL] = 0;

    // name
    //
    if (t[5UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // fullname
    //
    if (t[6UL])
    {
      i.fullname_value.capacity (i.fullname_size);
      grew = true;
    }

    // shortname
    //
    if (t[7UL])
    {
      i.shortname_value.capacity (i.shortname_size);
      grew = true;
    }

    // inn
    //
    if (t[8UL])
    {
      i.inn_value.capacity (i.inn_size);
      grew = true;
    }

    // kpp
    //
    if (t[9UL])
    {
      i.kpp_value.capacity (i.kpp_size);
      grew = true;
    }

    // ogrn
    //
    if (t[10UL])
    {
      i.ogrn_value.capacity (i.ogrn_size);
      grew = true;
    }

    // phone
    //
    if (t[11UL])
    {
      i.phone_value.capacity (i.phone_size);
      grew = true;
    }

    // email
    //
    if (t[12UL])
    {
      i.email_value.capacity (i.email_size);
      grew = true;
    }

    // currentaccount
    //
    if (t[13UL])
    {
      i.currentaccount_value.capacity (i.currentaccount_size);
      grew = true;
    }

    // correspondentaccount
    //
    if (t[14UL])
    {
      i.correspondentaccount_value.capacity (i.correspondentaccount_size);
      grew = true;
    }

    // description
    //
    if (t[15UL])
    {
      i.description_value.capacity (i.description_size);
      grew = true;
    }

    // note
    //
    if (t[16UL])
    {
      i.note_value.capacity (i.note_size);
      grew = true;
    }

    // __isset
    //
    if (t[17UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // orgrole
    //
    mysql::enum_traits::bind (b[n],
                              i.orgrole_value,
                              i.orgrole_size,
                              &i.orgrole_null);
    n++;

    // orgtype
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.orgtype_value;
    b[n].is_null = &i.orgtype_null;
    n++;

    // start
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.start_value;
    b[n].is_null = &i.start_null;
    n++;

    // tag
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.tag_value;
    b[n].is_null = &i.tag_null;
    n++;

    // name
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.name_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.name_value.capacity ());
    b[n].length = &i.name_size;
    b[n].is_null = &i.name_null;
    n++;

    // fullname
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.fullname_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.fullname_value.capacity ());
    b[n].length = &i.fullname_size;
    b[n].is_null = &i.fullname_null;
    n++;

    // shortname
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.shortname_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.shortname_value.capacity ());
    b[n].length = &i.shortname_size;
    b[n].is_null = &i.shortname_null;
    n++;

    // inn
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.inn_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.inn_value.capacity ());
    b[n].length = &i.inn_size;
    b[n].is_null = &i.inn_null;
    n++;

    // kpp
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.kpp_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.kpp_value.capacity ());
    b[n].length = &i.kpp_size;
    b[n].is_null = &i.kpp_null;
    n++;

    // ogrn
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.ogrn_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.ogrn_value.capacity ());
    b[n].length = &i.ogrn_size;
    b[n].is_null = &i.ogrn_null;
    n++;

    // phone
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.phone_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.phone_value.capacity ());
    b[n].length = &i.phone_size;
    b[n].is_null = &i.phone_null;
    n++;

    // email
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.email_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.email_value.capacity ());
    b[n].length = &i.email_size;
    b[n].is_null = &i.email_null;
    n++;

    // currentaccount
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.currentaccount_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.currentaccount_value.capacity ());
    b[n].length = &i.currentaccount_size;
    b[n].is_null = &i.currentaccount_null;
    n++;

    // correspondentaccount
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.correspondentaccount_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.correspondentaccount_value.capacity ());
    b[n].length = &i.correspondentaccount_size;
    b[n].is_null = &i.correspondentaccount_null;
    n++;

    // description
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.description_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.description_value.capacity ());
    b[n].length = &i.description_size;
    b[n].is_null = &i.description_null;
    n++;

    // note
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.note_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.note_value.capacity ());
    b[n].length = &i.note_size;
    b[n].is_null = &i.note_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Org, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // orgrole
    //
    {
      ::taxi::OrgRole::type const& v =
        o.orgrole;

      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.orgrole_value,
            i.orgrole_size,
            is_null,
            v))
        grew = true;

      i.orgrole_null = is_null;
    }

    // orgtype
    //
    {
      ::taxi::OrgType::type const& v =
        o.orgtype;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::OrgType::type,
          mysql::id_ulong >::set_image (
        i.orgtype_value, is_null, v);
      i.orgtype_null = is_null;
    }

    // start
    //
    {
      ::taxi::DATE const& v =
        o.start;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.start_value, is_null, v);
      i.start_null = is_null;
    }

    // tag
    //
    {
      ::taxi::NUMBER32 const& v =
        o.tag;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.tag_value, is_null, v);
      i.tag_null = is_null;
    }

    // name
    //
    {
      ::taxi::STR const& v =
        o.name;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.name_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.name_value,
        size,
        is_null,
        v);
      i.name_null = is_null;
      i.name_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.name_value.capacity ());
    }

    // fullname
    //
    {
      ::taxi::STR const& v =
        o.fullname;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.fullname_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.fullname_value,
        size,
        is_null,
        v);
      i.fullname_null = is_null;
      i.fullname_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.fullname_value.capacity ());
    }

    // shortname
    //
    {
      ::taxi::STR const& v =
        o.shortname;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.shortname_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.shortname_value,
        size,
        is_null,
        v);
      i.shortname_null = is_null;
      i.shortname_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.shortname_value.capacity ());
    }

    // inn
    //
    {
      ::taxi::STR const& v =
        o.inn;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.inn_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.inn_value,
        size,
        is_null,
        v);
      i.inn_null = is_null;
      i.inn_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.inn_value.capacity ());
    }

    // kpp
    //
    {
      ::taxi::STR const& v =
        o.kpp;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.kpp_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.kpp_value,
        size,
        is_null,
        v);
      i.kpp_null = is_null;
      i.kpp_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.kpp_value.capacity ());
    }

    // ogrn
    //
    {
      ::taxi::STR const& v =
        o.ogrn;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.ogrn_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.ogrn_value,
        size,
        is_null,
        v);
      i.ogrn_null = is_null;
      i.ogrn_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.ogrn_value.capacity ());
    }

    // phone
    //
    {
      ::taxi::TEL const& v =
        o.phone;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.phone_value.capacity ());
      mysql::value_traits<
          ::taxi::TEL,
          mysql::id_string >::set_image (
        i.phone_value,
        size,
        is_null,
        v);
      i.phone_null = is_null;
      i.phone_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.phone_value.capacity ());
    }

    // email
    //
    {
      ::taxi::MAILTO const& v =
        o.email;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.email_value.capacity ());
      mysql::value_traits<
          ::taxi::MAILTO,
          mysql::id_string >::set_image (
        i.email_value,
        size,
        is_null,
        v);
      i.email_null = is_null;
      i.email_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.email_value.capacity ());
    }

    // currentaccount
    //
    {
      ::taxi::STR const& v =
        o.currentaccount;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.currentaccount_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.currentaccount_value,
        size,
        is_null,
        v);
      i.currentaccount_null = is_null;
      i.currentaccount_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.currentaccount_value.capacity ());
    }

    // correspondentaccount
    //
    {
      ::taxi::STR const& v =
        o.correspondentaccount;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.correspondentaccount_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.correspondentaccount_value,
        size,
        is_null,
        v);
      i.correspondentaccount_null = is_null;
      i.correspondentaccount_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.correspondentaccount_value.capacity ());
    }

    // description
    //
    {
      ::taxi::STR const& v =
        o.description;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.description_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.description_value,
        size,
        is_null,
        v);
      i.description_null = is_null;
      i.description_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.description_value.capacity ());
    }

    // note
    //
    {
      ::taxi::STR const& v =
        o.note;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.note_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.note_value,
        size,
        is_null,
        v);
      i.note_null = is_null;
      i.note_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.note_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_Org__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Org__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // orgrole
    //
    {
      ::taxi::OrgRole::type& v =
        o.orgrole;

      mysql::enum_traits::set_value (
        v,
        i.orgrole_value,
        i.orgrole_size,
        i.orgrole_null);
    }

    // orgtype
    //
    {
      ::taxi::OrgType::type& v =
        o.orgtype;

      mysql::value_traits<
          ::taxi::OrgType::type,
          mysql::id_ulong >::set_value (
        v,
        i.orgtype_value,
        i.orgtype_null);
    }

    // start
    //
    {
      ::taxi::DATE& v =
        o.start;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.start_value,
        i.start_null);
    }

    // tag
    //
    {
      ::taxi::NUMBER32& v =
        o.tag;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.tag_value,
        i.tag_null);
    }

    // name
    //
    {
      ::taxi::STR& v =
        o.name;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // fullname
    //
    {
      ::taxi::STR& v =
        o.fullname;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.fullname_value,
        i.fullname_size,
        i.fullname_null);
    }

    // shortname
    //
    {
      ::taxi::STR& v =
        o.shortname;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.shortname_value,
        i.shortname_size,
        i.shortname_null);
    }

    // inn
    //
    {
      ::taxi::STR& v =
        o.inn;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.inn_value,
        i.inn_size,
        i.inn_null);
    }

    // kpp
    //
    {
      ::taxi::STR& v =
        o.kpp;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.kpp_value,
        i.kpp_size,
        i.kpp_null);
    }

    // ogrn
    //
    {
      ::taxi::STR& v =
        o.ogrn;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.ogrn_value,
        i.ogrn_size,
        i.ogrn_null);
    }

    // phone
    //
    {
      ::taxi::TEL& v =
        o.phone;

      mysql::value_traits<
          ::taxi::TEL,
          mysql::id_string >::set_value (
        v,
        i.phone_value,
        i.phone_size,
        i.phone_null);
    }

    // email
    //
    {
      ::taxi::MAILTO& v =
        o.email;

      mysql::value_traits<
          ::taxi::MAILTO,
          mysql::id_string >::set_value (
        v,
        i.email_value,
        i.email_size,
        i.email_null);
    }

    // currentaccount
    //
    {
      ::taxi::STR& v =
        o.currentaccount;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.currentaccount_value,
        i.currentaccount_size,
        i.currentaccount_null);
    }

    // correspondentaccount
    //
    {
      ::taxi::STR& v =
        o.correspondentaccount;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.correspondentaccount_value,
        i.correspondentaccount_size,
        i.correspondentaccount_null);
    }

    // description
    //
    {
      ::taxi::STR& v =
        o.description;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.description_value,
        i.description_size,
        i.description_null);
    }

    // note
    //
    {
      ::taxi::STR& v =
        o.note;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.note_value,
        i.note_size,
        i.note_null);
    }

    // __isset
    //
    {
      ::taxi::_Org__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Org__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::persist_statement[] =
  "INSERT INTO `Org` "
  "(`id`, "
  "`orgrole`, "
  "`orgtype`, "
  "`start`, "
  "`tag`, "
  "`name`, "
  "`fullname`, "
  "`shortname`, "
  "`inn`, "
  "`kpp`, "
  "`ogrn`, "
  "`phone`, "
  "`email`, "
  "`currentaccount`, "
  "`correspondentaccount`, "
  "`description`, "
  "`note`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::find_statement[] =
  "SELECT "
  "`Org`.`id`, "
  "CONCAT(`Org`.`orgrole`+0,' ',`Org`.`orgrole`), "
  "`Org`.`orgtype`, "
  "`Org`.`start`, "
  "`Org`.`tag`, "
  "`Org`.`name`, "
  "`Org`.`fullname`, "
  "`Org`.`shortname`, "
  "`Org`.`inn`, "
  "`Org`.`kpp`, "
  "`Org`.`ogrn`, "
  "`Org`.`phone`, "
  "`Org`.`email`, "
  "`Org`.`currentaccount`, "
  "`Org`.`correspondentaccount`, "
  "`Org`.`description`, "
  "`Org`.`note`, "
  "`Org`.`isset` "
  "FROM `Org` "
  "WHERE `Org`.`id`=?";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::update_statement[] =
  "UPDATE `Org` "
  "SET "
  "`orgrole`=?, "
  "`orgtype`=?, "
  "`start`=?, "
  "`tag`=?, "
  "`name`=?, "
  "`fullname`=?, "
  "`shortname`=?, "
  "`inn`=?, "
  "`kpp`=?, "
  "`ogrn`=?, "
  "`phone`=?, "
  "`email`=?, "
  "`currentaccount`=?, "
  "`correspondentaccount`=?, "
  "`description`=?, "
  "`note`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::erase_statement[] =
  "DELETE FROM `Org` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::query_statement[] =
  "SELECT "
  "`Org`.`id`, "
  "CONCAT(`Org`.`orgrole`+0,' ',`Org`.`orgrole`), "
  "`Org`.`orgtype`, "
  "`Org`.`start`, "
  "`Org`.`tag`, "
  "`Org`.`name`, "
  "`Org`.`fullname`, "
  "`Org`.`shortname`, "
  "`Org`.`inn`, "
  "`Org`.`kpp`, "
  "`Org`.`ogrn`, "
  "`Org`.`phone`, "
  "`Org`.`email`, "
  "`Org`.`currentaccount`, "
  "`Org`.`correspondentaccount`, "
  "`Org`.`description`, "
  "`Org`.`note`, "
  "`Org`.`isset` "
  "FROM `Org`";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Org`";

  const char access::object_traits_impl< ::taxi::Org, id_mysql >::table_name[] =
  "`Org`";

  void access::object_traits_impl< ::taxi::Org, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orgaddress
    //
    {
      ::taxi::OrgAddress const& v =
        obj.orgaddress;

      orgaddress_traits::persist (
        v,
        esc.orgaddress);
    }

    // employee
    //
    {
      ::taxi::OrgPositionPerson const& v =
        obj.employee;

      employee_traits::persist (
        v,
        esc.employee);
    }

    // bank
    //
    {
      ::taxi::OrgBank const& v =
        obj.bank;

      bank_traits::persist (
        v,
        esc.bank);
    }

    // orglocation
    //
    {
      ::taxi::OrgLocation const& v =
        obj.orglocation;

      orglocation_traits::persist (
        v,
        esc.orglocation);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orgaddress
    //
    {
      ::taxi::OrgAddress const& v =
        obj.orgaddress;

      orgaddress_traits::update (
        v,
        esc.orgaddress);
    }

    // employee
    //
    {
      ::taxi::OrgPositionPerson const& v =
        obj.employee;

      employee_traits::update (
        v,
        esc.employee);
    }

    // bank
    //
    {
      ::taxi::OrgBank const& v =
        obj.bank;

      bank_traits::update (
        v,
        esc.bank);
    }

    // orglocation
    //
    {
      ::taxi::OrgLocation const& v =
        obj.orglocation;

      orglocation_traits::update (
        v,
        esc.orglocation);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orgaddress
    //
    orgaddress_traits::erase (
      esc.orgaddress);

    // employee
    //
    employee_traits::erase (
      esc.employee);

    // bank
    //
    bank_traits::erase (
      esc.bank);

    // orglocation
    //
    orglocation_traits::erase (
      esc.orglocation);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Org, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Org, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Org, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Org, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Org, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Org, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orgaddress
    //
    {
      ::taxi::OrgAddress& v =
        obj.orgaddress;

      orgaddress_traits::load (
        v,
        esc.orgaddress);
    }

    // employee
    //
    {
      ::taxi::OrgPositionPerson& v =
        obj.employee;

      employee_traits::load (
        v,
        esc.employee);
    }

    // bank
    //
    {
      ::taxi::OrgBank& v =
        obj.bank;

      bank_traits::load (
        v,
        esc.bank);
    }

    // orglocation
    //
    {
      ::taxi::OrgLocation& v =
        obj.orglocation;

      orglocation_traits::load (
        v,
        esc.orglocation);
    }
  }

  result< access::object_traits_impl< ::taxi::Org, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Org, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Org, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // OrgService
  //

  struct access::object_traits_impl< ::taxi::OrgService, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< organization_traits > organization;
    mysql::container_statements_impl< orglocation_traits > orglocation;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : organization (c, id),
      orglocation (c, id)
    {
    }
  };

  // organization
  //

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`OrgService_organization`.`key`+0,' ',`OrgService_organization`.`key`), "
  "`OrgService_organization`.`value` "
  "FROM `OrgService_organization` "
  "WHERE `OrgService_organization`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  insert_statement[] =
  "INSERT INTO `OrgService_organization` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  delete_statement[] =
  "DELETE FROM `OrgService_organization` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::organization_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // orglocation
  //

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`OrgService_orglocation`.`key`+0,' ',`OrgService_orglocation`.`key`), "
  "`OrgService_orglocation`.`value_location_latitude`, "
  "`OrgService_orglocation`.`value_location_longitude`, "
  "`OrgService_orglocation`.`value_location_isset`, "
  "`OrgService_orglocation`.`value_name`, "
  "`OrgService_orglocation`.`value_city`, "
  "`OrgService_orglocation`.`value_address`, "
  "`OrgService_orglocation`.`value_isset` "
  "FROM `OrgService_orglocation` "
  "WHERE `OrgService_orglocation`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  insert_statement[] =
  "INSERT INTO `OrgService_orglocation` "
  "(`object_id`, "
  "`key`, "
  "`value_location_latitude`, "
  "`value_location_longitude`, "
  "`value_location_isset`, "
  "`value_name`, "
  "`value_city`, "
  "`value_address`, "
  "`value_isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  delete_statement[] =
  "DELETE FROM `OrgService_orglocation` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    composite_value_traits< value_type, id_mysql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    if (composite_value_traits< value_type, id_mysql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_mysql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_mysql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::orglocation_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::OrgService, id_mysql >::id_type
  access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // __isset
    //
    if (t[2UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // name
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.name_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.name_value.capacity ());
    b[n].length = &i.name_size;
    b[n].is_null = &i.name_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // name
    //
    {
      ::taxi::STR const& v =
        o.name;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.name_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.name_value,
        size,
        is_null,
        v);
      i.name_null = is_null;
      i.name_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.name_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_OrgService__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_OrgService__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // name
    //
    {
      ::taxi::STR& v =
        o.name;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // __isset
    //
    {
      ::taxi::_OrgService__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_OrgService__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::persist_statement[] =
  "INSERT INTO `OrgService` "
  "(`id`, "
  "`name`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::find_statement[] =
  "SELECT "
  "`OrgService`.`id`, "
  "`OrgService`.`name`, "
  "`OrgService`.`isset` "
  "FROM `OrgService` "
  "WHERE `OrgService`.`id`=?";

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::update_statement[] =
  "UPDATE `OrgService` "
  "SET "
  "`name`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::erase_statement[] =
  "DELETE FROM `OrgService` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::query_statement[] =
  "SELECT "
  "`OrgService`.`id`, "
  "`OrgService`.`name`, "
  "`OrgService`.`isset` "
  "FROM `OrgService`";

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::erase_query_statement[] =
  "DELETE FROM `OrgService`";

  const char access::object_traits_impl< ::taxi::OrgService, id_mysql >::table_name[] =
  "`OrgService`";

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // organization
    //
    {
      ::taxi::OrgServiceDepts const& v =
        obj.organization;

      organization_traits::persist (
        v,
        esc.organization);
    }

    // orglocation
    //
    {
      ::taxi::OrgLocation const& v =
        obj.orglocation;

      orglocation_traits::persist (
        v,
        esc.orglocation);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // organization
    //
    {
      ::taxi::OrgServiceDepts const& v =
        obj.organization;

      organization_traits::update (
        v,
        esc.organization);
    }

    // orglocation
    //
    {
      ::taxi::OrgLocation const& v =
        obj.orglocation;

      orglocation_traits::update (
        v,
        esc.orglocation);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // organization
    //
    organization_traits::erase (
      esc.organization);

    // orglocation
    //
    orglocation_traits::erase (
      esc.orglocation);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::OrgService, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // organization
    //
    {
      ::taxi::OrgServiceDepts& v =
        obj.organization;

      organization_traits::load (
        v,
        esc.organization);
    }

    // orglocation
    //
    {
      ::taxi::OrgLocation& v =
        obj.orglocation;

      orglocation_traits::load (
        v,
        esc.orglocation);
    }
  }

  result< access::object_traits_impl< ::taxi::OrgService, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::OrgService, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Customer
  //

  struct access::object_traits_impl< ::taxi::Customer, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< organization_traits > organization;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : organization (c, id)
    {
    }
  };

  // organization
  //

  const char access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Customer_organization`.`key`+0,' ',`Customer_organization`.`key`), "
  "`Customer_organization`.`value` "
  "FROM `Customer_organization` "
  "WHERE `Customer_organization`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  insert_statement[] =
  "INSERT INTO `Customer_organization` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  delete_statement[] =
  "DELETE FROM `Customer_organization` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::organization_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::Customer, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Customer, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Customer, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // cityid
    //
    t[1UL] = 0;

    // nickname
    //
    if (t[2UL])
    {
      i.nickname_value.capacity (i.nickname_size);
      grew = true;
    }

    // tag
    //
    t[3UL] = 0;

    // taxtype
    //
    t[4UL] = 0;

    // active
    //
    t[5UL] = 0;

    // enabled
    //
    t[6UL] = 0;

    // haspreferreddriver
    //
    t[7UL] = 0;

    // preferreddriverid
    //
    t[8UL] = 0;

    // hascredit
    //
    t[9UL] = 0;

    // hascreditlimit
    //
    t[10UL] = 0;

    // creditlimit
    //
    t[11UL] = 0;

    // __isset
    //
    if (t[12UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // cityid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.cityid_value;
    b[n].is_null = &i.cityid_null;
    n++;

    // nickname
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.nickname_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.nickname_value.capacity ());
    b[n].length = &i.nickname_size;
    b[n].is_null = &i.nickname_null;
    n++;

    // tag
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.tag_value;
    b[n].is_null = &i.tag_null;
    n++;

    // taxtype
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.taxtype_value;
    b[n].is_null = &i.taxtype_null;
    n++;

    // active
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.active_value;
    b[n].is_null = &i.active_null;
    n++;

    // enabled
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.enabled_value;
    b[n].is_null = &i.enabled_null;
    n++;

    // haspreferreddriver
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.haspreferreddriver_value;
    b[n].is_null = &i.haspreferreddriver_null;
    n++;

    // preferreddriverid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.preferreddriverid_value;
    b[n].is_null = &i.preferreddriverid_null;
    n++;

    // hascredit
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.hascredit_value;
    b[n].is_null = &i.hascredit_null;
    n++;

    // hascreditlimit
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.hascreditlimit_value;
    b[n].is_null = &i.hascreditlimit_null;
    n++;

    // creditlimit
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.creditlimit_value;
    b[n].is_null = &i.creditlimit_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Customer, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // cityid
    //
    {
      ::taxi::ID const& v =
        o.cityid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.cityid_value, is_null, v);
      i.cityid_null = is_null;
    }

    // nickname
    //
    {
      ::taxi::STR const& v =
        o.nickname;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.nickname_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.nickname_value,
        size,
        is_null,
        v);
      i.nickname_null = is_null;
      i.nickname_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.nickname_value.capacity ());
    }

    // tag
    //
    {
      ::taxi::TAG const& v =
        o.tag;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::TAG,
          mysql::id_long >::set_image (
        i.tag_value, is_null, v);
      i.tag_null = is_null;
    }

    // taxtype
    //
    {
      ::taxi::TaxType::type const& v =
        o.taxtype;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::TaxType::type,
          mysql::id_ulong >::set_image (
        i.taxtype_value, is_null, v);
      i.taxtype_null = is_null;
    }

    // active
    //
    {
      bool const& v =
        o.active;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.active_value, is_null, v);
      i.active_null = is_null;
    }

    // enabled
    //
    {
      bool const& v =
        o.enabled;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.enabled_value, is_null, v);
      i.enabled_null = is_null;
    }

    // haspreferreddriver
    //
    {
      bool const& v =
        o.haspreferreddriver;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.haspreferreddriver_value, is_null, v);
      i.haspreferreddriver_null = is_null;
    }

    // preferreddriverid
    //
    {
      ::taxi::ID const& v =
        o.preferreddriverid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.preferreddriverid_value, is_null, v);
      i.preferreddriverid_null = is_null;
    }

    // hascredit
    //
    {
      bool const& v =
        o.hascredit;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.hascredit_value, is_null, v);
      i.hascredit_null = is_null;
    }

    // hascreditlimit
    //
    {
      bool const& v =
        o.hascreditlimit;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.hascreditlimit_value, is_null, v);
      i.hascreditlimit_null = is_null;
    }

    // creditlimit
    //
    {
      ::taxi::CURR const& v =
        o.creditlimit;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.creditlimit_value, is_null, v);
      i.creditlimit_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_Customer__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Customer__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // cityid
    //
    {
      ::taxi::ID& v =
        o.cityid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.cityid_value,
        i.cityid_null);
    }

    // nickname
    //
    {
      ::taxi::STR& v =
        o.nickname;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.nickname_value,
        i.nickname_size,
        i.nickname_null);
    }

    // tag
    //
    {
      ::taxi::TAG& v =
        o.tag;

      mysql::value_traits<
          ::taxi::TAG,
          mysql::id_long >::set_value (
        v,
        i.tag_value,
        i.tag_null);
    }

    // taxtype
    //
    {
      ::taxi::TaxType::type& v =
        o.taxtype;

      mysql::value_traits<
          ::taxi::TaxType::type,
          mysql::id_ulong >::set_value (
        v,
        i.taxtype_value,
        i.taxtype_null);
    }

    // active
    //
    {
      bool& v =
        o.active;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.active_value,
        i.active_null);
    }

    // enabled
    //
    {
      bool& v =
        o.enabled;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.enabled_value,
        i.enabled_null);
    }

    // haspreferreddriver
    //
    {
      bool& v =
        o.haspreferreddriver;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.haspreferreddriver_value,
        i.haspreferreddriver_null);
    }

    // preferreddriverid
    //
    {
      ::taxi::ID& v =
        o.preferreddriverid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.preferreddriverid_value,
        i.preferreddriverid_null);
    }

    // hascredit
    //
    {
      bool& v =
        o.hascredit;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.hascredit_value,
        i.hascredit_null);
    }

    // hascreditlimit
    //
    {
      bool& v =
        o.hascreditlimit;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.hascreditlimit_value,
        i.hascreditlimit_null);
    }

    // creditlimit
    //
    {
      ::taxi::CURR& v =
        o.creditlimit;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.creditlimit_value,
        i.creditlimit_null);
    }

    // __isset
    //
    {
      ::taxi::_Customer__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Customer__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Customer, id_mysql >::persist_statement[] =
  "INSERT INTO `Customer` "
  "(`id`, "
  "`cityid`, "
  "`nickname`, "
  "`tag`, "
  "`taxtype`, "
  "`active`, "
  "`enabled`, "
  "`haspreferreddriver`, "
  "`preferreddriverid`, "
  "`hascredit`, "
  "`hascreditlimit`, "
  "`creditlimit`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Customer, id_mysql >::find_statement[] =
  "SELECT "
  "`Customer`.`id`, "
  "`Customer`.`cityid`, "
  "`Customer`.`nickname`, "
  "`Customer`.`tag`, "
  "`Customer`.`taxtype`, "
  "`Customer`.`active`, "
  "`Customer`.`enabled`, "
  "`Customer`.`haspreferreddriver`, "
  "`Customer`.`preferreddriverid`, "
  "`Customer`.`hascredit`, "
  "`Customer`.`hascreditlimit`, "
  "`Customer`.`creditlimit`, "
  "`Customer`.`isset` "
  "FROM `Customer` "
  "WHERE `Customer`.`id`=?";

  const char access::object_traits_impl< ::taxi::Customer, id_mysql >::update_statement[] =
  "UPDATE `Customer` "
  "SET "
  "`cityid`=?, "
  "`nickname`=?, "
  "`tag`=?, "
  "`taxtype`=?, "
  "`active`=?, "
  "`enabled`=?, "
  "`haspreferreddriver`=?, "
  "`preferreddriverid`=?, "
  "`hascredit`=?, "
  "`hascreditlimit`=?, "
  "`creditlimit`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Customer, id_mysql >::erase_statement[] =
  "DELETE FROM `Customer` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Customer, id_mysql >::query_statement[] =
  "SELECT "
  "`Customer`.`id`, "
  "`Customer`.`cityid`, "
  "`Customer`.`nickname`, "
  "`Customer`.`tag`, "
  "`Customer`.`taxtype`, "
  "`Customer`.`active`, "
  "`Customer`.`enabled`, "
  "`Customer`.`haspreferreddriver`, "
  "`Customer`.`preferreddriverid`, "
  "`Customer`.`hascredit`, "
  "`Customer`.`hascreditlimit`, "
  "`Customer`.`creditlimit`, "
  "`Customer`.`isset` "
  "FROM `Customer`";

  const char access::object_traits_impl< ::taxi::Customer, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Customer`";

  const char access::object_traits_impl< ::taxi::Customer, id_mysql >::table_name[] =
  "`Customer`";

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // organization
    //
    {
      ::taxi::OrgServiceDepts const& v =
        obj.organization;

      organization_traits::persist (
        v,
        esc.organization);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // organization
    //
    {
      ::taxi::OrgServiceDepts const& v =
        obj.organization;

      organization_traits::update (
        v,
        esc.organization);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // organization
    //
    organization_traits::erase (
      esc.organization);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Customer, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Customer, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Customer, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Customer, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Customer, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Customer, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // organization
    //
    {
      ::taxi::OrgServiceDepts& v =
        obj.organization;

      organization_traits::load (
        v,
        esc.organization);
    }
  }

  result< access::object_traits_impl< ::taxi::Customer, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Customer, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Customer, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Passenger
  //

  struct access::object_traits_impl< ::taxi::Passenger, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< passengerlimitmonth_traits > passengerlimitmonth;
    mysql::container_statements_impl< passengerusagemonth_traits > passengerusagemonth;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : passengerlimitmonth (c, id),
      passengerusagemonth (c, id)
    {
    }
  };

  // passengerlimitmonth
  //

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Passenger_passengerlimitmonth`.`key`+0,' ',`Passenger_passengerlimitmonth`.`key`), "
  "`Passenger_passengerlimitmonth`.`value_id`, "
  "`Passenger_passengerlimitmonth`.`value_tripcount`, "
  "`Passenger_passengerlimitmonth`.`value_minutescount`, "
  "`Passenger_passengerlimitmonth`.`value_moneycount`, "
  "`Passenger_passengerlimitmonth`.`value_isset` "
  "FROM `Passenger_passengerlimitmonth` "
  "WHERE `Passenger_passengerlimitmonth`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  insert_statement[] =
  "INSERT INTO `Passenger_passengerlimitmonth` "
  "(`object_id`, "
  "`key`, "
  "`value_id`, "
  "`value_tripcount`, "
  "`value_minutescount`, "
  "`value_moneycount`, "
  "`value_isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  delete_statement[] =
  "DELETE FROM `Passenger_passengerlimitmonth` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    composite_value_traits< value_type, id_mysql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    if (composite_value_traits< value_type, id_mysql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_mysql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_mysql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerlimitmonth_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // passengerusagemonth
  //

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Passenger_passengerusagemonth`.`key`+0,' ',`Passenger_passengerusagemonth`.`key`), "
  "`Passenger_passengerusagemonth`.`value_id`, "
  "`Passenger_passengerusagemonth`.`value_tripcount`, "
  "`Passenger_passengerusagemonth`.`value_minutescount`, "
  "`Passenger_passengerusagemonth`.`value_moneycount`, "
  "`Passenger_passengerusagemonth`.`value_payload_passengercount`, "
  "`Passenger_passengerusagemonth`.`value_payload_baggagecount`, "
  "`Passenger_passengerusagemonth`.`value_payload_baggageweight`, "
  "`Passenger_passengerusagemonth`.`value_payload_baggagewidth`, "
  "`Passenger_passengerusagemonth`.`value_payload_baggageheight`, "
  "`Passenger_passengerusagemonth`.`value_payload_papercount`, "
  "`Passenger_passengerusagemonth`.`value_payload_stopcount`, "
  "`Passenger_passengerusagemonth`.`value_payload_isset`, "
  "`Passenger_passengerusagemonth`.`value_isset` "
  "FROM `Passenger_passengerusagemonth` "
  "WHERE `Passenger_passengerusagemonth`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  insert_statement[] =
  "INSERT INTO `Passenger_passengerusagemonth` "
  "(`object_id`, "
  "`key`, "
  "`value_id`, "
  "`value_tripcount`, "
  "`value_minutescount`, "
  "`value_moneycount`, "
  "`value_payload_passengercount`, "
  "`value_payload_baggagecount`, "
  "`value_payload_baggageweight`, "
  "`value_payload_baggagewidth`, "
  "`value_payload_baggageheight`, "
  "`value_payload_papercount`, "
  "`value_payload_stopcount`, "
  "`value_payload_isset`, "
  "`value_isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  delete_statement[] =
  "DELETE FROM `Passenger_passengerusagemonth` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    composite_value_traits< value_type, id_mysql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    if (composite_value_traits< value_type, id_mysql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_mysql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_mysql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::passengerusagemonth_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::Passenger, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // cityid
    //
    t[1UL] = 0;

    // customerid
    //
    t[2UL] = 0;

    // tag
    //
    t[3UL] = 0;

    // isoperator
    //
    t[4UL] = 0;

    // isvip
    //
    t[5UL] = 0;

    // status
    //
    t[6UL] = 0;

    // personid
    //
    t[7UL] = 0;

    // canorder
    //
    t[8UL] = 0;

    // __isset
    //
    if (t[9UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // cityid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.cityid_value;
    b[n].is_null = &i.cityid_null;
    n++;

    // customerid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.customerid_value;
    b[n].is_null = &i.customerid_null;
    n++;

    // tag
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.tag_value;
    b[n].is_null = &i.tag_null;
    n++;

    // isoperator
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.isoperator_value;
    b[n].is_null = &i.isoperator_null;
    n++;

    // isvip
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.isvip_value;
    b[n].is_null = &i.isvip_null;
    n++;

    // status
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.status_value;
    b[n].is_null = &i.status_null;
    n++;

    // personid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.personid_value;
    b[n].is_null = &i.personid_null;
    n++;

    // canorder
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.canorder_value;
    b[n].is_null = &i.canorder_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // cityid
    //
    {
      ::taxi::ID const& v =
        o.cityid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.cityid_value, is_null, v);
      i.cityid_null = is_null;
    }

    // customerid
    //
    {
      ::taxi::ID const& v =
        o.customerid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.customerid_value, is_null, v);
      i.customerid_null = is_null;
    }

    // tag
    //
    {
      ::taxi::NUMBER32 const& v =
        o.tag;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.tag_value, is_null, v);
      i.tag_null = is_null;
    }

    // isoperator
    //
    {
      bool const& v =
        o.isoperator;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.isoperator_value, is_null, v);
      i.isoperator_null = is_null;
    }

    // isvip
    //
    {
      bool const& v =
        o.isvip;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.isvip_value, is_null, v);
      i.isvip_null = is_null;
    }

    // status
    //
    {
      ::taxi::EmployeeStatus::type const& v =
        o.status;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::EmployeeStatus::type,
          mysql::id_ulong >::set_image (
        i.status_value, is_null, v);
      i.status_null = is_null;
    }

    // personid
    //
    {
      ::taxi::Personid const& v =
        o.personid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::Personid,
          mysql::id_longlong >::set_image (
        i.personid_value, is_null, v);
      i.personid_null = is_null;
    }

    // canorder
    //
    {
      ::taxi::CanOrder::type const& v =
        o.canorder;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CanOrder::type,
          mysql::id_ulong >::set_image (
        i.canorder_value, is_null, v);
      i.canorder_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_Passenger__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Passenger__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // cityid
    //
    {
      ::taxi::ID& v =
        o.cityid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.cityid_value,
        i.cityid_null);
    }

    // customerid
    //
    {
      ::taxi::ID& v =
        o.customerid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.customerid_value,
        i.customerid_null);
    }

    // tag
    //
    {
      ::taxi::NUMBER32& v =
        o.tag;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.tag_value,
        i.tag_null);
    }

    // isoperator
    //
    {
      bool& v =
        o.isoperator;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.isoperator_value,
        i.isoperator_null);
    }

    // isvip
    //
    {
      bool& v =
        o.isvip;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.isvip_value,
        i.isvip_null);
    }

    // status
    //
    {
      ::taxi::EmployeeStatus::type& v =
        o.status;

      mysql::value_traits<
          ::taxi::EmployeeStatus::type,
          mysql::id_ulong >::set_value (
        v,
        i.status_value,
        i.status_null);
    }

    // personid
    //
    {
      ::taxi::Personid& v =
        o.personid;

      mysql::value_traits<
          ::taxi::Personid,
          mysql::id_longlong >::set_value (
        v,
        i.personid_value,
        i.personid_null);
    }

    // canorder
    //
    {
      ::taxi::CanOrder::type& v =
        o.canorder;

      mysql::value_traits<
          ::taxi::CanOrder::type,
          mysql::id_ulong >::set_value (
        v,
        i.canorder_value,
        i.canorder_null);
    }

    // __isset
    //
    {
      ::taxi::_Passenger__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Passenger__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::persist_statement[] =
  "INSERT INTO `Passenger` "
  "(`id`, "
  "`cityid`, "
  "`customerid`, "
  "`tag`, "
  "`isoperator`, "
  "`isvip`, "
  "`status`, "
  "`personid`, "
  "`canorder`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::find_statement[] =
  "SELECT "
  "`Passenger`.`id`, "
  "`Passenger`.`cityid`, "
  "`Passenger`.`customerid`, "
  "`Passenger`.`tag`, "
  "`Passenger`.`isoperator`, "
  "`Passenger`.`isvip`, "
  "`Passenger`.`status`, "
  "`Passenger`.`personid`, "
  "`Passenger`.`canorder`, "
  "`Passenger`.`isset` "
  "FROM `Passenger` "
  "WHERE `Passenger`.`id`=?";

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::update_statement[] =
  "UPDATE `Passenger` "
  "SET "
  "`cityid`=?, "
  "`customerid`=?, "
  "`tag`=?, "
  "`isoperator`=?, "
  "`isvip`=?, "
  "`status`=?, "
  "`personid`=?, "
  "`canorder`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::erase_statement[] =
  "DELETE FROM `Passenger` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::query_statement[] =
  "SELECT "
  "`Passenger`.`id`, "
  "`Passenger`.`cityid`, "
  "`Passenger`.`customerid`, "
  "`Passenger`.`tag`, "
  "`Passenger`.`isoperator`, "
  "`Passenger`.`isvip`, "
  "`Passenger`.`status`, "
  "`Passenger`.`personid`, "
  "`Passenger`.`canorder`, "
  "`Passenger`.`isset` "
  "FROM `Passenger`";

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Passenger`";

  const char access::object_traits_impl< ::taxi::Passenger, id_mysql >::table_name[] =
  "`Passenger`";

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // passengerlimitmonth
    //
    {
      ::taxi::PassengerLimitMonth const& v =
        obj.passengerlimitmonth;

      passengerlimitmonth_traits::persist (
        v,
        esc.passengerlimitmonth);
    }

    // passengerusagemonth
    //
    {
      ::taxi::PassengerUsageMonth const& v =
        obj.passengerusagemonth;

      passengerusagemonth_traits::persist (
        v,
        esc.passengerusagemonth);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // passengerlimitmonth
    //
    {
      ::taxi::PassengerLimitMonth const& v =
        obj.passengerlimitmonth;

      passengerlimitmonth_traits::update (
        v,
        esc.passengerlimitmonth);
    }

    // passengerusagemonth
    //
    {
      ::taxi::PassengerUsageMonth const& v =
        obj.passengerusagemonth;

      passengerusagemonth_traits::update (
        v,
        esc.passengerusagemonth);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // passengerlimitmonth
    //
    passengerlimitmonth_traits::erase (
      esc.passengerlimitmonth);

    // passengerusagemonth
    //
    passengerusagemonth_traits::erase (
      esc.passengerusagemonth);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Passenger, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // passengerlimitmonth
    //
    {
      ::taxi::PassengerLimitMonth& v =
        obj.passengerlimitmonth;

      passengerlimitmonth_traits::load (
        v,
        esc.passengerlimitmonth);
    }

    // passengerusagemonth
    //
    {
      ::taxi::PassengerUsageMonth& v =
        obj.passengerusagemonth;

      passengerusagemonth_traits::load (
        v,
        esc.passengerusagemonth);
    }
  }

  result< access::object_traits_impl< ::taxi::Passenger, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Passenger, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Vehicle
  //

  struct access::object_traits_impl< ::taxi::Vehicle, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::Vehicle, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // vehicletype
    //
    t[1UL] = 0;

    // vehiclecategory
    //
    t[2UL] = 0;

    // vehicleclass
    //
    t[3UL] = 0;

    // vehiclestatus
    //
    t[4UL] = 0;

    // vehiclebrandid
    //
    t[5UL] = 0;

    // vehiclemodel
    //
    t[6UL] = 0;

    // color
    //
    t[7UL] = 0;

    // year
    //
    t[8UL] = 0;

    // plate
    //
    if (t[9UL])
    {
      i.plate_value.capacity (i.plate_size);
      grew = true;
    }

    // platenumber
    //
    t[10UL] = 0;

    // technicalcondition
    //
    if (t[11UL])
    {
      i.technicalcondition_value.capacity (i.technicalcondition_size);
      grew = true;
    }

    // passengercount
    //
    t[12UL] = 0;

    // childseat
    //
    t[13UL] = 0;

    // checkers
    //
    t[14UL] = 0;

    // stickers
    //
    t[15UL] = 0;

    // lantern
    //
    t[16UL] = 0;

    // photo
    //
    if (t[17UL])
    {
      i.photo_value.capacity (i.photo_size);
      grew = true;
    }

    // vin
    //
    if (t[18UL])
    {
      i.vin_value.capacity (i.vin_size);
      grew = true;
    }

    // __isset
    //
    if (t[19UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // vehicletype
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.vehicletype_value;
    b[n].is_null = &i.vehicletype_null;
    n++;

    // vehiclecategory
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.vehiclecategory_value;
    b[n].is_null = &i.vehiclecategory_null;
    n++;

    // vehicleclass
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.vehicleclass_value;
    b[n].is_null = &i.vehicleclass_null;
    n++;

    // vehiclestatus
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.vehiclestatus_value;
    b[n].is_null = &i.vehiclestatus_null;
    n++;

    // vehiclebrandid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.vehiclebrandid_value;
    b[n].is_null = &i.vehiclebrandid_null;
    n++;

    // vehiclemodel
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.vehiclemodel_value;
    b[n].is_null = &i.vehiclemodel_null;
    n++;

    // color
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.color_value;
    b[n].is_null = &i.color_null;
    n++;

    // year
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.year_value;
    b[n].is_null = &i.year_null;
    n++;

    // plate
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.plate_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.plate_value.capacity ());
    b[n].length = &i.plate_size;
    b[n].is_null = &i.plate_null;
    n++;

    // platenumber
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.platenumber_value;
    b[n].is_null = &i.platenumber_null;
    n++;

    // technicalcondition
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.technicalcondition_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.technicalcondition_value.capacity ());
    b[n].length = &i.technicalcondition_size;
    b[n].is_null = &i.technicalcondition_null;
    n++;

    // passengercount
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.passengercount_value;
    b[n].is_null = &i.passengercount_null;
    n++;

    // childseat
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.childseat_value;
    b[n].is_null = &i.childseat_null;
    n++;

    // checkers
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.checkers_value;
    b[n].is_null = &i.checkers_null;
    n++;

    // stickers
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.stickers_value;
    b[n].is_null = &i.stickers_null;
    n++;

    // lantern
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.lantern_value;
    b[n].is_null = &i.lantern_null;
    n++;

    // photo
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.photo_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.photo_value.capacity ());
    b[n].length = &i.photo_size;
    b[n].is_null = &i.photo_null;
    n++;

    // vin
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.vin_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.vin_value.capacity ());
    b[n].length = &i.vin_size;
    b[n].is_null = &i.vin_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // vehicletype
    //
    {
      ::taxi::VehicleType::type const& v =
        o.vehicletype;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::VehicleType::type,
          mysql::id_ulong >::set_image (
        i.vehicletype_value, is_null, v);
      i.vehicletype_null = is_null;
    }

    // vehiclecategory
    //
    {
      ::taxi::VehicleCategory::type const& v =
        o.vehiclecategory;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::VehicleCategory::type,
          mysql::id_ulong >::set_image (
        i.vehiclecategory_value, is_null, v);
      i.vehiclecategory_null = is_null;
    }

    // vehicleclass
    //
    {
      ::taxi::VehicleClass::type const& v =
        o.vehicleclass;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::VehicleClass::type,
          mysql::id_ulong >::set_image (
        i.vehicleclass_value, is_null, v);
      i.vehicleclass_null = is_null;
    }

    // vehiclestatus
    //
    {
      ::taxi::VehicleStatus::type const& v =
        o.vehiclestatus;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::VehicleStatus::type,
          mysql::id_ulong >::set_image (
        i.vehiclestatus_value, is_null, v);
      i.vehiclestatus_null = is_null;
    }

    // vehiclebrandid
    //
    {
      ::taxi::ID const& v =
        o.vehiclebrandid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.vehiclebrandid_value, is_null, v);
      i.vehiclebrandid_null = is_null;
    }

    // vehiclemodel
    //
    {
      ::taxi::ID const& v =
        o.vehiclemodel;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.vehiclemodel_value, is_null, v);
      i.vehiclemodel_null = is_null;
    }

    // color
    //
    {
      ::taxi::ID const& v =
        o.color;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.color_value, is_null, v);
      i.color_null = is_null;
    }

    // year
    //
    {
      ::taxi::NUMBER32 const& v =
        o.year;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.year_value, is_null, v);
      i.year_null = is_null;
    }

    // plate
    //
    {
      ::taxi::STR const& v =
        o.plate;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.plate_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.plate_value,
        size,
        is_null,
        v);
      i.plate_null = is_null;
      i.plate_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.plate_value.capacity ());
    }

    // platenumber
    //
    {
      ::taxi::NUMBER32 const& v =
        o.platenumber;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.platenumber_value, is_null, v);
      i.platenumber_null = is_null;
    }

    // technicalcondition
    //
    {
      ::taxi::STR const& v =
        o.technicalcondition;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.technicalcondition_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.technicalcondition_value,
        size,
        is_null,
        v);
      i.technicalcondition_null = is_null;
      i.technicalcondition_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.technicalcondition_value.capacity ());
    }

    // passengercount
    //
    {
      ::taxi::NUMBER32 const& v =
        o.passengercount;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.passengercount_value, is_null, v);
      i.passengercount_null = is_null;
    }

    // childseat
    //
    {
      bool const& v =
        o.childseat;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.childseat_value, is_null, v);
      i.childseat_null = is_null;
    }

    // checkers
    //
    {
      bool const& v =
        o.checkers;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.checkers_value, is_null, v);
      i.checkers_null = is_null;
    }

    // stickers
    //
    {
      bool const& v =
        o.stickers;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.stickers_value, is_null, v);
      i.stickers_null = is_null;
    }

    // lantern
    //
    {
      bool const& v =
        o.lantern;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.lantern_value, is_null, v);
      i.lantern_null = is_null;
    }

    // photo
    //
    {
      ::taxi::LINK const& v =
        o.photo;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.photo_value.capacity ());
      mysql::value_traits<
          ::taxi::LINK,
          mysql::id_string >::set_image (
        i.photo_value,
        size,
        is_null,
        v);
      i.photo_null = is_null;
      i.photo_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.photo_value.capacity ());
    }

    // vin
    //
    {
      ::taxi::STR const& v =
        o.vin;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.vin_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.vin_value,
        size,
        is_null,
        v);
      i.vin_null = is_null;
      i.vin_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.vin_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_Vehicle__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Vehicle__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // vehicletype
    //
    {
      ::taxi::VehicleType::type& v =
        o.vehicletype;

      mysql::value_traits<
          ::taxi::VehicleType::type,
          mysql::id_ulong >::set_value (
        v,
        i.vehicletype_value,
        i.vehicletype_null);
    }

    // vehiclecategory
    //
    {
      ::taxi::VehicleCategory::type& v =
        o.vehiclecategory;

      mysql::value_traits<
          ::taxi::VehicleCategory::type,
          mysql::id_ulong >::set_value (
        v,
        i.vehiclecategory_value,
        i.vehiclecategory_null);
    }

    // vehicleclass
    //
    {
      ::taxi::VehicleClass::type& v =
        o.vehicleclass;

      mysql::value_traits<
          ::taxi::VehicleClass::type,
          mysql::id_ulong >::set_value (
        v,
        i.vehicleclass_value,
        i.vehicleclass_null);
    }

    // vehiclestatus
    //
    {
      ::taxi::VehicleStatus::type& v =
        o.vehiclestatus;

      mysql::value_traits<
          ::taxi::VehicleStatus::type,
          mysql::id_ulong >::set_value (
        v,
        i.vehiclestatus_value,
        i.vehiclestatus_null);
    }

    // vehiclebrandid
    //
    {
      ::taxi::ID& v =
        o.vehiclebrandid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.vehiclebrandid_value,
        i.vehiclebrandid_null);
    }

    // vehiclemodel
    //
    {
      ::taxi::ID& v =
        o.vehiclemodel;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.vehiclemodel_value,
        i.vehiclemodel_null);
    }

    // color
    //
    {
      ::taxi::ID& v =
        o.color;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.color_value,
        i.color_null);
    }

    // year
    //
    {
      ::taxi::NUMBER32& v =
        o.year;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.year_value,
        i.year_null);
    }

    // plate
    //
    {
      ::taxi::STR& v =
        o.plate;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.plate_value,
        i.plate_size,
        i.plate_null);
    }

    // platenumber
    //
    {
      ::taxi::NUMBER32& v =
        o.platenumber;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.platenumber_value,
        i.platenumber_null);
    }

    // technicalcondition
    //
    {
      ::taxi::STR& v =
        o.technicalcondition;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.technicalcondition_value,
        i.technicalcondition_size,
        i.technicalcondition_null);
    }

    // passengercount
    //
    {
      ::taxi::NUMBER32& v =
        o.passengercount;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.passengercount_value,
        i.passengercount_null);
    }

    // childseat
    //
    {
      bool& v =
        o.childseat;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.childseat_value,
        i.childseat_null);
    }

    // checkers
    //
    {
      bool& v =
        o.checkers;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.checkers_value,
        i.checkers_null);
    }

    // stickers
    //
    {
      bool& v =
        o.stickers;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.stickers_value,
        i.stickers_null);
    }

    // lantern
    //
    {
      bool& v =
        o.lantern;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.lantern_value,
        i.lantern_null);
    }

    // photo
    //
    {
      ::taxi::LINK& v =
        o.photo;

      mysql::value_traits<
          ::taxi::LINK,
          mysql::id_string >::set_value (
        v,
        i.photo_value,
        i.photo_size,
        i.photo_null);
    }

    // vin
    //
    {
      ::taxi::STR& v =
        o.vin;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.vin_value,
        i.vin_size,
        i.vin_null);
    }

    // __isset
    //
    {
      ::taxi::_Vehicle__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Vehicle__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Vehicle, id_mysql >::persist_statement[] =
  "INSERT INTO `Vehicle` "
  "(`id`, "
  "`vehicletype`, "
  "`vehiclecategory`, "
  "`vehicleclass`, "
  "`vehiclestatus`, "
  "`vehiclebrandid`, "
  "`vehiclemodel`, "
  "`color`, "
  "`year`, "
  "`plate`, "
  "`platenumber`, "
  "`technicalcondition`, "
  "`passengercount`, "
  "`childseat`, "
  "`checkers`, "
  "`stickers`, "
  "`lantern`, "
  "`photo`, "
  "`vin`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Vehicle, id_mysql >::find_statement[] =
  "SELECT "
  "`Vehicle`.`id`, "
  "`Vehicle`.`vehicletype`, "
  "`Vehicle`.`vehiclecategory`, "
  "`Vehicle`.`vehicleclass`, "
  "`Vehicle`.`vehiclestatus`, "
  "`Vehicle`.`vehiclebrandid`, "
  "`Vehicle`.`vehiclemodel`, "
  "`Vehicle`.`color`, "
  "`Vehicle`.`year`, "
  "`Vehicle`.`plate`, "
  "`Vehicle`.`platenumber`, "
  "`Vehicle`.`technicalcondition`, "
  "`Vehicle`.`passengercount`, "
  "`Vehicle`.`childseat`, "
  "`Vehicle`.`checkers`, "
  "`Vehicle`.`stickers`, "
  "`Vehicle`.`lantern`, "
  "`Vehicle`.`photo`, "
  "`Vehicle`.`vin`, "
  "`Vehicle`.`isset` "
  "FROM `Vehicle` "
  "WHERE `Vehicle`.`id`=?";

  const char access::object_traits_impl< ::taxi::Vehicle, id_mysql >::update_statement[] =
  "UPDATE `Vehicle` "
  "SET "
  "`vehicletype`=?, "
  "`vehiclecategory`=?, "
  "`vehicleclass`=?, "
  "`vehiclestatus`=?, "
  "`vehiclebrandid`=?, "
  "`vehiclemodel`=?, "
  "`color`=?, "
  "`year`=?, "
  "`plate`=?, "
  "`platenumber`=?, "
  "`technicalcondition`=?, "
  "`passengercount`=?, "
  "`childseat`=?, "
  "`checkers`=?, "
  "`stickers`=?, "
  "`lantern`=?, "
  "`photo`=?, "
  "`vin`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Vehicle, id_mysql >::erase_statement[] =
  "DELETE FROM `Vehicle` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Vehicle, id_mysql >::query_statement[] =
  "SELECT "
  "`Vehicle`.`id`, "
  "`Vehicle`.`vehicletype`, "
  "`Vehicle`.`vehiclecategory`, "
  "`Vehicle`.`vehicleclass`, "
  "`Vehicle`.`vehiclestatus`, "
  "`Vehicle`.`vehiclebrandid`, "
  "`Vehicle`.`vehiclemodel`, "
  "`Vehicle`.`color`, "
  "`Vehicle`.`year`, "
  "`Vehicle`.`plate`, "
  "`Vehicle`.`platenumber`, "
  "`Vehicle`.`technicalcondition`, "
  "`Vehicle`.`passengercount`, "
  "`Vehicle`.`childseat`, "
  "`Vehicle`.`checkers`, "
  "`Vehicle`.`stickers`, "
  "`Vehicle`.`lantern`, "
  "`Vehicle`.`photo`, "
  "`Vehicle`.`vin`, "
  "`Vehicle`.`isset` "
  "FROM `Vehicle`";

  const char access::object_traits_impl< ::taxi::Vehicle, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Vehicle`";

  const char access::object_traits_impl< ::taxi::Vehicle, id_mysql >::table_name[] =
  "`Vehicle`";

  void access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Vehicle, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::Vehicle, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Vehicle, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Document
  //

  struct access::object_traits_impl< ::taxi::Document, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::Document, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Document, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Document, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // ser
    //
    if (t[1UL])
    {
      i.ser_value.capacity (i.ser_size);
      grew = true;
    }

    // number
    //
    if (t[2UL])
    {
      i.number_value.capacity (i.number_size);
      grew = true;
    }

    // issuer
    //
    if (t[3UL])
    {
      i.issuer_value.capacity (i.issuer_size);
      grew = true;
    }

    // issued
    //
    t[4UL] = 0;

    // validity
    //
    t[5UL] = 0;

    // category
    //
    if (t[6UL])
    {
      i.category_value.capacity (i.category_size);
      grew = true;
    }

    // expirience
    //
    t[7UL] = 0;

    // __isset
    //
    if (t[8UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Document, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // ser
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.ser_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.ser_value.capacity ());
    b[n].length = &i.ser_size;
    b[n].is_null = &i.ser_null;
    n++;

    // number
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.number_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.number_value.capacity ());
    b[n].length = &i.number_size;
    b[n].is_null = &i.number_null;
    n++;

    // issuer
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.issuer_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.issuer_value.capacity ());
    b[n].length = &i.issuer_size;
    b[n].is_null = &i.issuer_null;
    n++;

    // issued
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.issued_value;
    b[n].is_null = &i.issued_null;
    n++;

    // validity
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.validity_value;
    b[n].is_null = &i.validity_null;
    n++;

    // category
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.category_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.category_value.capacity ());
    b[n].length = &i.category_size;
    b[n].is_null = &i.category_null;
    n++;

    // expirience
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.expirience_value;
    b[n].is_null = &i.expirience_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Document, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Document, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // ser
    //
    {
      ::taxi::STR const& v =
        o.ser;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.ser_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.ser_value,
        size,
        is_null,
        v);
      i.ser_null = is_null;
      i.ser_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.ser_value.capacity ());
    }

    // number
    //
    {
      ::taxi::STR const& v =
        o.number;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.number_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.number_value,
        size,
        is_null,
        v);
      i.number_null = is_null;
      i.number_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.number_value.capacity ());
    }

    // issuer
    //
    {
      ::taxi::STR const& v =
        o.issuer;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.issuer_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.issuer_value,
        size,
        is_null,
        v);
      i.issuer_null = is_null;
      i.issuer_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.issuer_value.capacity ());
    }

    // issued
    //
    {
      ::taxi::DATE const& v =
        o.issued;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.issued_value, is_null, v);
      i.issued_null = is_null;
    }

    // validity
    //
    {
      ::taxi::DATE const& v =
        o.validity;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.validity_value, is_null, v);
      i.validity_null = is_null;
    }

    // category
    //
    {
      ::taxi::STR const& v =
        o.category;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.category_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.category_value,
        size,
        is_null,
        v);
      i.category_null = is_null;
      i.category_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.category_value.capacity ());
    }

    // expirience
    //
    {
      ::taxi::NUMBER32 const& v =
        o.expirience;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.expirience_value, is_null, v);
      i.expirience_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_Document__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Document__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Document, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // ser
    //
    {
      ::taxi::STR& v =
        o.ser;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.ser_value,
        i.ser_size,
        i.ser_null);
    }

    // number
    //
    {
      ::taxi::STR& v =
        o.number;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.number_value,
        i.number_size,
        i.number_null);
    }

    // issuer
    //
    {
      ::taxi::STR& v =
        o.issuer;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.issuer_value,
        i.issuer_size,
        i.issuer_null);
    }

    // issued
    //
    {
      ::taxi::DATE& v =
        o.issued;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.issued_value,
        i.issued_null);
    }

    // validity
    //
    {
      ::taxi::DATE& v =
        o.validity;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.validity_value,
        i.validity_null);
    }

    // category
    //
    {
      ::taxi::STR& v =
        o.category;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.category_value,
        i.category_size,
        i.category_null);
    }

    // expirience
    //
    {
      ::taxi::NUMBER32& v =
        o.expirience;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.expirience_value,
        i.expirience_null);
    }

    // __isset
    //
    {
      ::taxi::_Document__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Document__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Document, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Document, id_mysql >::persist_statement[] =
  "INSERT INTO `Document` "
  "(`id`, "
  "`ser`, "
  "`number`, "
  "`issuer`, "
  "`issued`, "
  "`validity`, "
  "`category`, "
  "`expirience`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Document, id_mysql >::find_statement[] =
  "SELECT "
  "`Document`.`id`, "
  "`Document`.`ser`, "
  "`Document`.`number`, "
  "`Document`.`issuer`, "
  "`Document`.`issued`, "
  "`Document`.`validity`, "
  "`Document`.`category`, "
  "`Document`.`expirience`, "
  "`Document`.`isset` "
  "FROM `Document` "
  "WHERE `Document`.`id`=?";

  const char access::object_traits_impl< ::taxi::Document, id_mysql >::update_statement[] =
  "UPDATE `Document` "
  "SET "
  "`ser`=?, "
  "`number`=?, "
  "`issuer`=?, "
  "`issued`=?, "
  "`validity`=?, "
  "`category`=?, "
  "`expirience`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Document, id_mysql >::erase_statement[] =
  "DELETE FROM `Document` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Document, id_mysql >::query_statement[] =
  "SELECT "
  "`Document`.`id`, "
  "`Document`.`ser`, "
  "`Document`.`number`, "
  "`Document`.`issuer`, "
  "`Document`.`issued`, "
  "`Document`.`validity`, "
  "`Document`.`category`, "
  "`Document`.`expirience`, "
  "`Document`.`isset` "
  "FROM `Document`";

  const char access::object_traits_impl< ::taxi::Document, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Document`";

  const char access::object_traits_impl< ::taxi::Document, id_mysql >::table_name[] =
  "`Document`";

  void access::object_traits_impl< ::taxi::Document, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Document, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Document, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Document, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Document, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Document, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Document, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Document, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::Document, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Document, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Document, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Driver
  //

  struct access::object_traits_impl< ::taxi::Driver, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< svc_traits > svc;
    mysql::container_statements_impl< person_traits > person;
    mysql::container_statements_impl< license_traits > license;
    mysql::container_statements_impl< vehicleids_traits > vehicleids;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : svc (c, id),
      person (c, id),
      license (c, id),
      vehicleids (c, id)
    {
    }
  };

  // svc
  //

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Driver_svc`.`key`+0,' ',`Driver_svc`.`key`), "
  "`Driver_svc`.`value` "
  "FROM `Driver_svc` "
  "WHERE `Driver_svc`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  insert_statement[] =
  "INSERT INTO `Driver_svc` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  delete_statement[] =
  "DELETE FROM `Driver_svc` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::svc_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // person
  //

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Driver_person`.`key`+0,' ',`Driver_person`.`key`), "
  "`Driver_person`.`value_credentials_phone`, "
  "CONCAT(`Driver_person`.`value_credentials_personrole`+0,' ',`Driver_person`.`value_credentials_personrole`), "
  "`Driver_person`.`value_credentials_token`, "
  "`Driver_person`.`value_credentials_password`, "
  "`Driver_person`.`value_credentials_islogged`, "
  "`Driver_person`.`value_credentials_timelogon`, "
  "`Driver_person`.`value_credentials_isset`, "
  "`Driver_person`.`value_tag`, "
  "`Driver_person`.`value_firstname`, "
  "`Driver_person`.`value_lastname`, "
  "`Driver_person`.`value_middlename`, "
  "`Driver_person`.`value_prefix`, "
  "`Driver_person`.`value_birthdate`, "
  "`Driver_person`.`value_deparment`, "
  "`Driver_person`.`value_position`, "
  "`Driver_person`.`value_note`, "
  "`Driver_person`.`value_phone1`, "
  "`Driver_person`.`value_phone2`, "
  "`Driver_person`.`value_fax`, "
  "`Driver_person`.`value_email`, "
  "`Driver_person`.`value_photo`, "
  "`Driver_person`.`value_isset` "
  "FROM `Driver_person` "
  "WHERE `Driver_person`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  insert_statement[] =
  "INSERT INTO `Driver_person` "
  "(`object_id`, "
  "`key`, "
  "`value_credentials_phone`, "
  "`value_credentials_personrole`, "
  "`value_credentials_token`, "
  "`value_credentials_password`, "
  "`value_credentials_islogged`, "
  "`value_credentials_timelogon`, "
  "`value_credentials_isset`, "
  "`value_tag`, "
  "`value_firstname`, "
  "`value_lastname`, "
  "`value_middlename`, "
  "`value_prefix`, "
  "`value_birthdate`, "
  "`value_deparment`, "
  "`value_position`, "
  "`value_note`, "
  "`value_phone1`, "
  "`value_phone2`, "
  "`value_fax`, "
  "`value_email`, "
  "`value_photo`, "
  "`value_isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  delete_statement[] =
  "DELETE FROM `Driver_person` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    composite_value_traits< value_type, id_mysql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    if (composite_value_traits< value_type, id_mysql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_mysql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_mysql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::person_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // license
  //

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  select_statement[] =
  "SELECT "
  "`Driver_license`.`key`, "
  "`Driver_license`.`value` "
  "FROM `Driver_license` "
  "WHERE `Driver_license`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  insert_statement[] =
  "INSERT INTO `Driver_license` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  delete_statement[] =
  "DELETE FROM `Driver_license` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &d.key_value;
    b[n].is_null = &d.key_null;
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    t[0UL] = 0;

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      mysql::value_traits<
          key_type,
          mysql::id_ulong >::set_image (
        i.key_value, is_null, *k);
      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::value_traits<
          key_type,
          mysql::id_ulong >::set_value (
        k,
        i.key_value,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::license_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // vehicleids
  //

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  select_statement[] =
  "SELECT "
  "`Driver_vehicleids`.`index`, "
  "`Driver_vehicleids`.`value` "
  "FROM `Driver_vehicleids` "
  "WHERE `Driver_vehicleids`.`object_id`=? ORDER BY `Driver_vehicleids`.`index`";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  insert_statement[] =
  "INSERT INTO `Driver_vehicleids` "
  "(`object_id`, "
  "`index`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  delete_statement[] =
  "DELETE FROM `Driver_vehicleids` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::vehicleids_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::Driver, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Driver, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Driver, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // cityid
    //
    t[1UL] = 0;

    // status
    //
    t[2UL] = 0;

    // nickname
    //
    if (t[3UL])
    {
      i.nickname_value.capacity (i.nickname_size);
      grew = true;
    }

    // callsign
    //
    t[4UL] = 0;

    // cabclass
    //
    t[5UL] = 0;

    // rating
    //
    t[6UL] = 0;

    // online
    //
    t[7UL] = 0;

    // __isset
    //
    if (t[8UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // cityid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.cityid_value;
    b[n].is_null = &i.cityid_null;
    n++;

    // status
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.status_value;
    b[n].is_null = &i.status_null;
    n++;

    // nickname
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.nickname_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.nickname_value.capacity ());
    b[n].length = &i.nickname_size;
    b[n].is_null = &i.nickname_null;
    n++;

    // callsign
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.callsign_value;
    b[n].is_null = &i.callsign_null;
    n++;

    // cabclass
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.cabclass_value;
    b[n].is_null = &i.cabclass_null;
    n++;

    // rating
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.rating_value;
    b[n].is_null = &i.rating_null;
    n++;

    // online
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.online_value;
    b[n].is_null = &i.online_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Driver, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // cityid
    //
    {
      ::taxi::ID const& v =
        o.cityid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.cityid_value, is_null, v);
      i.cityid_null = is_null;
    }

    // status
    //
    {
      ::taxi::EmployeeStatus::type const& v =
        o.status;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::EmployeeStatus::type,
          mysql::id_ulong >::set_image (
        i.status_value, is_null, v);
      i.status_null = is_null;
    }

    // nickname
    //
    {
      ::taxi::STR const& v =
        o.nickname;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.nickname_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.nickname_value,
        size,
        is_null,
        v);
      i.nickname_null = is_null;
      i.nickname_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.nickname_value.capacity ());
    }

    // callsign
    //
    {
      ::taxi::NUMBER32 const& v =
        o.callsign;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.callsign_value, is_null, v);
      i.callsign_null = is_null;
    }

    // cabclass
    //
    {
      ::taxi::CabClass::type const& v =
        o.cabclass;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CabClass::type,
          mysql::id_ulong >::set_image (
        i.cabclass_value, is_null, v);
      i.cabclass_null = is_null;
    }

    // rating
    //
    {
      ::taxi::NUMBER32 const& v =
        o.rating;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.rating_value, is_null, v);
      i.rating_null = is_null;
    }

    // online
    //
    {
      bool const& v =
        o.online;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.online_value, is_null, v);
      i.online_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_Driver__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Driver__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // cityid
    //
    {
      ::taxi::ID& v =
        o.cityid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.cityid_value,
        i.cityid_null);
    }

    // status
    //
    {
      ::taxi::EmployeeStatus::type& v =
        o.status;

      mysql::value_traits<
          ::taxi::EmployeeStatus::type,
          mysql::id_ulong >::set_value (
        v,
        i.status_value,
        i.status_null);
    }

    // nickname
    //
    {
      ::taxi::STR& v =
        o.nickname;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.nickname_value,
        i.nickname_size,
        i.nickname_null);
    }

    // callsign
    //
    {
      ::taxi::NUMBER32& v =
        o.callsign;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.callsign_value,
        i.callsign_null);
    }

    // cabclass
    //
    {
      ::taxi::CabClass::type& v =
        o.cabclass;

      mysql::value_traits<
          ::taxi::CabClass::type,
          mysql::id_ulong >::set_value (
        v,
        i.cabclass_value,
        i.cabclass_null);
    }

    // rating
    //
    {
      ::taxi::NUMBER32& v =
        o.rating;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.rating_value,
        i.rating_null);
    }

    // online
    //
    {
      bool& v =
        o.online;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.online_value,
        i.online_null);
    }

    // __isset
    //
    {
      ::taxi::_Driver__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Driver__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::persist_statement[] =
  "INSERT INTO `Driver` "
  "(`id`, "
  "`cityid`, "
  "`status`, "
  "`nickname`, "
  "`callsign`, "
  "`cabclass`, "
  "`rating`, "
  "`online`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::find_statement[] =
  "SELECT "
  "`Driver`.`id`, "
  "`Driver`.`cityid`, "
  "`Driver`.`status`, "
  "`Driver`.`nickname`, "
  "`Driver`.`callsign`, "
  "`Driver`.`cabclass`, "
  "`Driver`.`rating`, "
  "`Driver`.`online`, "
  "`Driver`.`isset` "
  "FROM `Driver` "
  "WHERE `Driver`.`id`=?";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::update_statement[] =
  "UPDATE `Driver` "
  "SET "
  "`cityid`=?, "
  "`status`=?, "
  "`nickname`=?, "
  "`callsign`=?, "
  "`cabclass`=?, "
  "`rating`=?, "
  "`online`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::erase_statement[] =
  "DELETE FROM `Driver` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::query_statement[] =
  "SELECT "
  "`Driver`.`id`, "
  "`Driver`.`cityid`, "
  "`Driver`.`status`, "
  "`Driver`.`nickname`, "
  "`Driver`.`callsign`, "
  "`Driver`.`cabclass`, "
  "`Driver`.`rating`, "
  "`Driver`.`online`, "
  "`Driver`.`isset` "
  "FROM `Driver`";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Driver`";

  const char access::object_traits_impl< ::taxi::Driver, id_mysql >::table_name[] =
  "`Driver`";

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // svc
    //
    {
      ::taxi::RoleOrgService const& v =
        obj.svc;

      svc_traits::persist (
        v,
        esc.svc);
    }

    // person
    //
    {
      ::taxi::OrgPositionPerson const& v =
        obj.person;

      person_traits::persist (
        v,
        esc.person);
    }

    // license
    //
    {
      ::taxi::DocumentMap const& v =
        obj.license;

      license_traits::persist (
        v,
        esc.license);
    }

    // vehicleids
    //
    {
      ::taxi::Vehicleids const& v =
        obj.vehicleids;

      vehicleids_traits::persist (
        v,
        esc.vehicleids);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // svc
    //
    {
      ::taxi::RoleOrgService const& v =
        obj.svc;

      svc_traits::update (
        v,
        esc.svc);
    }

    // person
    //
    {
      ::taxi::OrgPositionPerson const& v =
        obj.person;

      person_traits::update (
        v,
        esc.person);
    }

    // license
    //
    {
      ::taxi::DocumentMap const& v =
        obj.license;

      license_traits::update (
        v,
        esc.license);
    }

    // vehicleids
    //
    {
      ::taxi::Vehicleids const& v =
        obj.vehicleids;

      vehicleids_traits::update (
        v,
        esc.vehicleids);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // svc
    //
    svc_traits::erase (
      esc.svc);

    // person
    //
    person_traits::erase (
      esc.person);

    // license
    //
    license_traits::erase (
      esc.license);

    // vehicleids
    //
    vehicleids_traits::erase (
      esc.vehicleids);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Driver, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Driver, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Driver, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Driver, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Driver, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Driver, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // svc
    //
    {
      ::taxi::RoleOrgService& v =
        obj.svc;

      svc_traits::load (
        v,
        esc.svc);
    }

    // person
    //
    {
      ::taxi::OrgPositionPerson& v =
        obj.person;

      person_traits::load (
        v,
        esc.person);
    }

    // license
    //
    {
      ::taxi::DocumentMap& v =
        obj.license;

      license_traits::load (
        v,
        esc.license);
    }

    // vehicleids
    //
    {
      ::taxi::Vehicleids& v =
        obj.vehicleids;

      vehicleids_traits::load (
        v,
        esc.vehicleids);
    }
  }

  result< access::object_traits_impl< ::taxi::Driver, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Driver, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Driver, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Dispatcher
  //

  struct access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< svc_traits > svc;
    mysql::container_statements_impl< person_traits > person;
    mysql::container_statements_impl< license_traits > license;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : svc (c, id),
      person (c, id),
      license (c, id)
    {
    }
  };

  // svc
  //

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Dispatcher_svc`.`key`+0,' ',`Dispatcher_svc`.`key`), "
  "`Dispatcher_svc`.`value` "
  "FROM `Dispatcher_svc` "
  "WHERE `Dispatcher_svc`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  insert_statement[] =
  "INSERT INTO `Dispatcher_svc` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  delete_statement[] =
  "DELETE FROM `Dispatcher_svc` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::svc_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // person
  //

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`Dispatcher_person`.`key`+0,' ',`Dispatcher_person`.`key`), "
  "`Dispatcher_person`.`value_credentials_phone`, "
  "CONCAT(`Dispatcher_person`.`value_credentials_personrole`+0,' ',`Dispatcher_person`.`value_credentials_personrole`), "
  "`Dispatcher_person`.`value_credentials_token`, "
  "`Dispatcher_person`.`value_credentials_password`, "
  "`Dispatcher_person`.`value_credentials_islogged`, "
  "`Dispatcher_person`.`value_credentials_timelogon`, "
  "`Dispatcher_person`.`value_credentials_isset`, "
  "`Dispatcher_person`.`value_tag`, "
  "`Dispatcher_person`.`value_firstname`, "
  "`Dispatcher_person`.`value_lastname`, "
  "`Dispatcher_person`.`value_middlename`, "
  "`Dispatcher_person`.`value_prefix`, "
  "`Dispatcher_person`.`value_birthdate`, "
  "`Dispatcher_person`.`value_deparment`, "
  "`Dispatcher_person`.`value_position`, "
  "`Dispatcher_person`.`value_note`, "
  "`Dispatcher_person`.`value_phone1`, "
  "`Dispatcher_person`.`value_phone2`, "
  "`Dispatcher_person`.`value_fax`, "
  "`Dispatcher_person`.`value_email`, "
  "`Dispatcher_person`.`value_photo`, "
  "`Dispatcher_person`.`value_isset` "
  "FROM `Dispatcher_person` "
  "WHERE `Dispatcher_person`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  insert_statement[] =
  "INSERT INTO `Dispatcher_person` "
  "(`object_id`, "
  "`key`, "
  "`value_credentials_phone`, "
  "`value_credentials_personrole`, "
  "`value_credentials_token`, "
  "`value_credentials_password`, "
  "`value_credentials_islogged`, "
  "`value_credentials_timelogon`, "
  "`value_credentials_isset`, "
  "`value_tag`, "
  "`value_firstname`, "
  "`value_lastname`, "
  "`value_middlename`, "
  "`value_prefix`, "
  "`value_birthdate`, "
  "`value_deparment`, "
  "`value_position`, "
  "`value_note`, "
  "`value_phone1`, "
  "`value_phone2`, "
  "`value_fax`, "
  "`value_email`, "
  "`value_photo`, "
  "`value_isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  delete_statement[] =
  "DELETE FROM `Dispatcher_person` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    composite_value_traits< value_type, id_mysql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    if (composite_value_traits< value_type, id_mysql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_mysql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_mysql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::person_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // license
  //

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  select_statement[] =
  "SELECT "
  "`Dispatcher_license`.`key`, "
  "`Dispatcher_license`.`value` "
  "FROM `Dispatcher_license` "
  "WHERE `Dispatcher_license`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  insert_statement[] =
  "INSERT INTO `Dispatcher_license` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  delete_statement[] =
  "DELETE FROM `Dispatcher_license` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &d.key_value;
    b[n].is_null = &d.key_null;
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    t[0UL] = 0;

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      mysql::value_traits<
          key_type,
          mysql::id_ulong >::set_image (
        i.key_value, is_null, *k);
      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::value_traits<
          key_type,
          mysql::id_ulong >::set_value (
        k,
        i.key_value,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::license_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // status
    //
    t[1UL] = 0;

    // nickname
    //
    if (t[2UL])
    {
      i.nickname_value.capacity (i.nickname_size);
      grew = true;
    }

    // online
    //
    t[3UL] = 0;

    // __isset
    //
    if (t[4UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // status
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.status_value;
    b[n].is_null = &i.status_null;
    n++;

    // nickname
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.nickname_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.nickname_value.capacity ());
    b[n].length = &i.nickname_size;
    b[n].is_null = &i.nickname_null;
    n++;

    // online
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.online_value;
    b[n].is_null = &i.online_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // status
    //
    {
      ::taxi::EmployeeStatus::type const& v =
        o.status;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::EmployeeStatus::type,
          mysql::id_ulong >::set_image (
        i.status_value, is_null, v);
      i.status_null = is_null;
    }

    // nickname
    //
    {
      ::taxi::STR const& v =
        o.nickname;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.nickname_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.nickname_value,
        size,
        is_null,
        v);
      i.nickname_null = is_null;
      i.nickname_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.nickname_value.capacity ());
    }

    // online
    //
    {
      bool const& v =
        o.online;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.online_value, is_null, v);
      i.online_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_Dispatcher__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Dispatcher__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // status
    //
    {
      ::taxi::EmployeeStatus::type& v =
        o.status;

      mysql::value_traits<
          ::taxi::EmployeeStatus::type,
          mysql::id_ulong >::set_value (
        v,
        i.status_value,
        i.status_null);
    }

    // nickname
    //
    {
      ::taxi::STR& v =
        o.nickname;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.nickname_value,
        i.nickname_size,
        i.nickname_null);
    }

    // online
    //
    {
      bool& v =
        o.online;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.online_value,
        i.online_null);
    }

    // __isset
    //
    {
      ::taxi::_Dispatcher__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Dispatcher__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::persist_statement[] =
  "INSERT INTO `Dispatcher` "
  "(`id`, "
  "`status`, "
  "`nickname`, "
  "`online`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::find_statement[] =
  "SELECT "
  "`Dispatcher`.`id`, "
  "`Dispatcher`.`status`, "
  "`Dispatcher`.`nickname`, "
  "`Dispatcher`.`online`, "
  "`Dispatcher`.`isset` "
  "FROM `Dispatcher` "
  "WHERE `Dispatcher`.`id`=?";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::update_statement[] =
  "UPDATE `Dispatcher` "
  "SET "
  "`status`=?, "
  "`nickname`=?, "
  "`online`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::erase_statement[] =
  "DELETE FROM `Dispatcher` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::query_statement[] =
  "SELECT "
  "`Dispatcher`.`id`, "
  "`Dispatcher`.`status`, "
  "`Dispatcher`.`nickname`, "
  "`Dispatcher`.`online`, "
  "`Dispatcher`.`isset` "
  "FROM `Dispatcher`";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Dispatcher`";

  const char access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::table_name[] =
  "`Dispatcher`";

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // svc
    //
    {
      ::taxi::RoleOrgService const& v =
        obj.svc;

      svc_traits::persist (
        v,
        esc.svc);
    }

    // person
    //
    {
      ::taxi::OrgPositionPerson const& v =
        obj.person;

      person_traits::persist (
        v,
        esc.person);
    }

    // license
    //
    {
      ::taxi::DocumentMap const& v =
        obj.license;

      license_traits::persist (
        v,
        esc.license);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // svc
    //
    {
      ::taxi::RoleOrgService const& v =
        obj.svc;

      svc_traits::update (
        v,
        esc.svc);
    }

    // person
    //
    {
      ::taxi::OrgPositionPerson const& v =
        obj.person;

      person_traits::update (
        v,
        esc.person);
    }

    // license
    //
    {
      ::taxi::DocumentMap const& v =
        obj.license;

      license_traits::update (
        v,
        esc.license);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // svc
    //
    svc_traits::erase (
      esc.svc);

    // person
    //
    person_traits::erase (
      esc.person);

    // license
    //
    license_traits::erase (
      esc.license);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // svc
    //
    {
      ::taxi::RoleOrgService& v =
        obj.svc;

      svc_traits::load (
        v,
        esc.svc);
    }

    // person
    //
    {
      ::taxi::OrgPositionPerson& v =
        obj.person;

      person_traits::load (
        v,
        esc.person);
    }

    // license
    //
    {
      ::taxi::DocumentMap& v =
        obj.license;

      license_traits::load (
        v,
        esc.license);
    }
  }

  result< access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Dispatcher, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // ServiceOrderStop
  //

  struct access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< pickuppersons_traits > pickuppersons;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : pickuppersons (c, id)
    {
    }
  };

  // pickuppersons
  //

  const char access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  select_statement[] =
  "SELECT "
  "`ServiceOrderStop_pickuppersons`.`index`, "
  "`ServiceOrderStop_pickuppersons`.`value_credentials_phone`, "
  "CONCAT(`ServiceOrderStop_pickuppersons`.`value_credentials_personrole`+0,' ',`ServiceOrderStop_pickuppersons`.`value_credentials_personrole`), "
  "`ServiceOrderStop_pickuppersons`.`value_credentials_token`, "
  "`ServiceOrderStop_pickuppersons`.`value_credentials_password`, "
  "`ServiceOrderStop_pickuppersons`.`value_credentials_islogged`, "
  "`ServiceOrderStop_pickuppersons`.`value_credentials_timelogon`, "
  "`ServiceOrderStop_pickuppersons`.`value_credentials_isset`, "
  "`ServiceOrderStop_pickuppersons`.`value_tag`, "
  "`ServiceOrderStop_pickuppersons`.`value_firstname`, "
  "`ServiceOrderStop_pickuppersons`.`value_lastname`, "
  "`ServiceOrderStop_pickuppersons`.`value_middlename`, "
  "`ServiceOrderStop_pickuppersons`.`value_prefix`, "
  "`ServiceOrderStop_pickuppersons`.`value_birthdate`, "
  "`ServiceOrderStop_pickuppersons`.`value_deparment`, "
  "`ServiceOrderStop_pickuppersons`.`value_position`, "
  "`ServiceOrderStop_pickuppersons`.`value_note`, "
  "`ServiceOrderStop_pickuppersons`.`value_phone1`, "
  "`ServiceOrderStop_pickuppersons`.`value_phone2`, "
  "`ServiceOrderStop_pickuppersons`.`value_fax`, "
  "`ServiceOrderStop_pickuppersons`.`value_email`, "
  "`ServiceOrderStop_pickuppersons`.`value_photo`, "
  "`ServiceOrderStop_pickuppersons`.`value_isset` "
  "FROM `ServiceOrderStop_pickuppersons` "
  "WHERE `ServiceOrderStop_pickuppersons`.`object_id`=? ORDER BY `ServiceOrderStop_pickuppersons`.`index`";

  const char access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  insert_statement[] =
  "INSERT INTO `ServiceOrderStop_pickuppersons` "
  "(`object_id`, "
  "`index`, "
  "`value_credentials_phone`, "
  "`value_credentials_personrole`, "
  "`value_credentials_token`, "
  "`value_credentials_password`, "
  "`value_credentials_islogged`, "
  "`value_credentials_timelogon`, "
  "`value_credentials_isset`, "
  "`value_tag`, "
  "`value_firstname`, "
  "`value_lastname`, "
  "`value_middlename`, "
  "`value_prefix`, "
  "`value_birthdate`, "
  "`value_deparment`, "
  "`value_position`, "
  "`value_note`, "
  "`value_phone1`, "
  "`value_phone2`, "
  "`value_fax`, "
  "`value_email`, "
  "`value_photo`, "
  "`value_isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  delete_statement[] =
  "DELETE FROM `ServiceOrderStop_pickuppersons` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    composite_value_traits< value_type, id_mysql >::bind (
      b + n, d.value_value, sk);
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    if (composite_value_traits< value_type, id_mysql >::grow (
          i.value_value, t + 1UL))
      grew = true;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      if (composite_value_traits< value_type, id_mysql >::init (
            i.value_value,
            v,
            sk))
        grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      composite_value_traits< value_type, id_mysql >::init (
        v,
        i.value_value,
        db);
    }
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pickuppersons_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::id_type
  access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // serviceorderid
    //
    t[1UL] = 0;

    // stopno
    //
    t[2UL] = 0;

    // stoptype
    //
    t[3UL] = 0;

    // payload
    //
    if (composite_value_traits< ::taxi::Payload, id_mysql >::grow (
          i.payload_value, t + 4UL))
      grew = true;

    // stage
    //
    t[12UL] = 0;

    // created
    //
    t[13UL] = 0;

    // assigned
    //
    t[14UL] = 0;

    // started
    //
    t[15UL] = 0;

    // arrived
    //
    t[16UL] = 0;

    // finished
    //
    t[17UL] = 0;

    // notes
    //
    if (t[18UL])
    {
      i.notes_value.capacity (i.notes_size);
      grew = true;
    }

    // __isset
    //
    if (t[19UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // serviceorderid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.serviceorderid_value;
    b[n].is_null = &i.serviceorderid_null;
    n++;

    // stopno
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.stopno_value;
    b[n].is_null = &i.stopno_null;
    n++;

    // stoptype
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.stoptype_value;
    b[n].is_null = &i.stoptype_null;
    n++;

    // payload
    //
    composite_value_traits< ::taxi::Payload, id_mysql >::bind (
      b + n, i.payload_value, sk);
    n += 8UL;

    // stage
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.stage_value;
    b[n].is_null = &i.stage_null;
    n++;

    // created
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.created_value;
    b[n].is_null = &i.created_null;
    n++;

    // assigned
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.assigned_value;
    b[n].is_null = &i.assigned_null;
    n++;

    // started
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.started_value;
    b[n].is_null = &i.started_null;
    n++;

    // arrived
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.arrived_value;
    b[n].is_null = &i.arrived_null;
    n++;

    // finished
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.finished_value;
    b[n].is_null = &i.finished_null;
    n++;

    // notes
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.notes_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.notes_value.capacity ());
    b[n].length = &i.notes_size;
    b[n].is_null = &i.notes_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // serviceorderid
    //
    {
      ::taxi::Serviceorderid const& v =
        o.serviceorderid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::Serviceorderid,
          mysql::id_longlong >::set_image (
        i.serviceorderid_value, is_null, v);
      i.serviceorderid_null = is_null;
    }

    // stopno
    //
    {
      ::taxi::NUMBER32 const& v =
        o.stopno;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.stopno_value, is_null, v);
      i.stopno_null = is_null;
    }

    // stoptype
    //
    {
      ::taxi::StopType::type const& v =
        o.stoptype;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::StopType::type,
          mysql::id_ulong >::set_image (
        i.stoptype_value, is_null, v);
      i.stoptype_null = is_null;
    }

    // payload
    //
    {
      ::taxi::Payload const& v =
        o.payload;

      if (composite_value_traits< ::taxi::Payload, id_mysql >::init (
            i.payload_value,
            v,
            sk))
        grew = true;
    }

    // stage
    //
    {
      ::taxi::OrderStage::type const& v =
        o.stage;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::OrderStage::type,
          mysql::id_ulong >::set_image (
        i.stage_value, is_null, v);
      i.stage_null = is_null;
    }

    // created
    //
    {
      ::taxi::DATE const& v =
        o.created;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.created_value, is_null, v);
      i.created_null = is_null;
    }

    // assigned
    //
    {
      ::taxi::DATE const& v =
        o.assigned;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.assigned_value, is_null, v);
      i.assigned_null = is_null;
    }

    // started
    //
    {
      ::taxi::DATE const& v =
        o.started;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.started_value, is_null, v);
      i.started_null = is_null;
    }

    // arrived
    //
    {
      ::taxi::DATE const& v =
        o.arrived;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.arrived_value, is_null, v);
      i.arrived_null = is_null;
    }

    // finished
    //
    {
      ::taxi::DATE const& v =
        o.finished;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.finished_value, is_null, v);
      i.finished_null = is_null;
    }

    // notes
    //
    {
      ::taxi::STR const& v =
        o.notes;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.notes_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.notes_value,
        size,
        is_null,
        v);
      i.notes_null = is_null;
      i.notes_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.notes_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_ServiceOrderStop__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_ServiceOrderStop__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // serviceorderid
    //
    {
      ::taxi::Serviceorderid& v =
        o.serviceorderid;

      mysql::value_traits<
          ::taxi::Serviceorderid,
          mysql::id_longlong >::set_value (
        v,
        i.serviceorderid_value,
        i.serviceorderid_null);
    }

    // stopno
    //
    {
      ::taxi::NUMBER32& v =
        o.stopno;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.stopno_value,
        i.stopno_null);
    }

    // stoptype
    //
    {
      ::taxi::StopType::type& v =
        o.stoptype;

      mysql::value_traits<
          ::taxi::StopType::type,
          mysql::id_ulong >::set_value (
        v,
        i.stoptype_value,
        i.stoptype_null);
    }

    // payload
    //
    {
      ::taxi::Payload& v =
        o.payload;

      composite_value_traits< ::taxi::Payload, id_mysql >::init (
        v,
        i.payload_value,
        db);
    }

    // stage
    //
    {
      ::taxi::OrderStage::type& v =
        o.stage;

      mysql::value_traits<
          ::taxi::OrderStage::type,
          mysql::id_ulong >::set_value (
        v,
        i.stage_value,
        i.stage_null);
    }

    // created
    //
    {
      ::taxi::DATE& v =
        o.created;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.created_value,
        i.created_null);
    }

    // assigned
    //
    {
      ::taxi::DATE& v =
        o.assigned;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.assigned_value,
        i.assigned_null);
    }

    // started
    //
    {
      ::taxi::DATE& v =
        o.started;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.started_value,
        i.started_null);
    }

    // arrived
    //
    {
      ::taxi::DATE& v =
        o.arrived;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.arrived_value,
        i.arrived_null);
    }

    // finished
    //
    {
      ::taxi::DATE& v =
        o.finished;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.finished_value,
        i.finished_null);
    }

    // notes
    //
    {
      ::taxi::STR& v =
        o.notes;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.notes_value,
        i.notes_size,
        i.notes_null);
    }

    // __isset
    //
    {
      ::taxi::_ServiceOrderStop__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_ServiceOrderStop__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::persist_statement[] =
  "INSERT INTO `ServiceOrderStop` "
  "(`id`, "
  "`serviceorderid`, "
  "`stopno`, "
  "`stoptype`, "
  "`payload_passengercount`, "
  "`payload_baggagecount`, "
  "`payload_baggageweight`, "
  "`payload_baggagewidth`, "
  "`payload_baggageheight`, "
  "`payload_papercount`, "
  "`payload_stopcount`, "
  "`payload_isset`, "
  "`stage`, "
  "`created`, "
  "`assigned`, "
  "`started`, "
  "`arrived`, "
  "`finished`, "
  "`notes`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::find_statement[] =
  "SELECT "
  "`ServiceOrderStop`.`id`, "
  "`ServiceOrderStop`.`serviceorderid`, "
  "`ServiceOrderStop`.`stopno`, "
  "`ServiceOrderStop`.`stoptype`, "
  "`ServiceOrderStop`.`payload_passengercount`, "
  "`ServiceOrderStop`.`payload_baggagecount`, "
  "`ServiceOrderStop`.`payload_baggageweight`, "
  "`ServiceOrderStop`.`payload_baggagewidth`, "
  "`ServiceOrderStop`.`payload_baggageheight`, "
  "`ServiceOrderStop`.`payload_papercount`, "
  "`ServiceOrderStop`.`payload_stopcount`, "
  "`ServiceOrderStop`.`payload_isset`, "
  "`ServiceOrderStop`.`stage`, "
  "`ServiceOrderStop`.`created`, "
  "`ServiceOrderStop`.`assigned`, "
  "`ServiceOrderStop`.`started`, "
  "`ServiceOrderStop`.`arrived`, "
  "`ServiceOrderStop`.`finished`, "
  "`ServiceOrderStop`.`notes`, "
  "`ServiceOrderStop`.`isset` "
  "FROM `ServiceOrderStop` "
  "WHERE `ServiceOrderStop`.`id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::update_statement[] =
  "UPDATE `ServiceOrderStop` "
  "SET "
  "`serviceorderid`=?, "
  "`stopno`=?, "
  "`stoptype`=?, "
  "`payload_passengercount`=?, "
  "`payload_baggagecount`=?, "
  "`payload_baggageweight`=?, "
  "`payload_baggagewidth`=?, "
  "`payload_baggageheight`=?, "
  "`payload_papercount`=?, "
  "`payload_stopcount`=?, "
  "`payload_isset`=?, "
  "`stage`=?, "
  "`created`=?, "
  "`assigned`=?, "
  "`started`=?, "
  "`arrived`=?, "
  "`finished`=?, "
  "`notes`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::erase_statement[] =
  "DELETE FROM `ServiceOrderStop` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::query_statement[] =
  "SELECT "
  "`ServiceOrderStop`.`id`, "
  "`ServiceOrderStop`.`serviceorderid`, "
  "`ServiceOrderStop`.`stopno`, "
  "`ServiceOrderStop`.`stoptype`, "
  "`ServiceOrderStop`.`payload_passengercount`, "
  "`ServiceOrderStop`.`payload_baggagecount`, "
  "`ServiceOrderStop`.`payload_baggageweight`, "
  "`ServiceOrderStop`.`payload_baggagewidth`, "
  "`ServiceOrderStop`.`payload_baggageheight`, "
  "`ServiceOrderStop`.`payload_papercount`, "
  "`ServiceOrderStop`.`payload_stopcount`, "
  "`ServiceOrderStop`.`payload_isset`, "
  "`ServiceOrderStop`.`stage`, "
  "`ServiceOrderStop`.`created`, "
  "`ServiceOrderStop`.`assigned`, "
  "`ServiceOrderStop`.`started`, "
  "`ServiceOrderStop`.`arrived`, "
  "`ServiceOrderStop`.`finished`, "
  "`ServiceOrderStop`.`notes`, "
  "`ServiceOrderStop`.`isset` "
  "FROM `ServiceOrderStop`";

  const char access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::erase_query_statement[] =
  "DELETE FROM `ServiceOrderStop`";

  const char access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::table_name[] =
  "`ServiceOrderStop`";

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // pickuppersons
    //
    {
      ::taxi::OrderStopPersons const& v =
        obj.pickuppersons;

      pickuppersons_traits::persist (
        v,
        esc.pickuppersons);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // pickuppersons
    //
    {
      ::taxi::OrderStopPersons const& v =
        obj.pickuppersons;

      pickuppersons_traits::update (
        v,
        esc.pickuppersons);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // pickuppersons
    //
    pickuppersons_traits::erase (
      esc.pickuppersons);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // pickuppersons
    //
    {
      ::taxi::OrderStopPersons& v =
        obj.pickuppersons;

      pickuppersons_traits::load (
        v,
        esc.pickuppersons);
    }
  }

  result< access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::ServiceOrderStop, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // ServiceOrder
  //

  struct access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< orderfeatures_traits > orderfeatures;
    mysql::container_statements_impl< svc_traits > svc;
    mysql::container_statements_impl< passengers_traits > passengers;
    mysql::container_statements_impl< stops_traits > stops;
    mysql::container_statements_impl< crew_traits > crew;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : orderfeatures (c, id),
      svc (c, id),
      passengers (c, id),
      stops (c, id),
      crew (c, id)
    {
    }
  };

  // orderfeatures
  //

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  select_statement[] =
  "SELECT "
  "`ServiceOrder_orderfeatures`.`value` "
  "FROM `ServiceOrder_orderfeatures` "
  "WHERE `ServiceOrder_orderfeatures`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  insert_statement[] =
  "INSERT INTO `ServiceOrder_orderfeatures` "
  "(`object_id`, "
  "`value`) "
  "VALUES "
  "(?, ?)";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  delete_statement[] =
  "DELETE FROM `ServiceOrder_orderfeatures` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // value
    //
    t[0UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  init (data_image_type& i,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_ulong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  init (value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_ulong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  insert (const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  select (value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::orderfeatures_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // svc
  //

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`ServiceOrder_svc`.`key`+0,' ',`ServiceOrder_svc`.`key`), "
  "`ServiceOrder_svc`.`value` "
  "FROM `ServiceOrder_svc` "
  "WHERE `ServiceOrder_svc`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  insert_statement[] =
  "INSERT INTO `ServiceOrder_svc` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  delete_statement[] =
  "DELETE FROM `ServiceOrder_svc` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::svc_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // passengers
  //

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  select_statement[] =
  "SELECT "
  "`ServiceOrder_passengers`.`index`, "
  "`ServiceOrder_passengers`.`value` "
  "FROM `ServiceOrder_passengers` "
  "WHERE `ServiceOrder_passengers`.`object_id`=? ORDER BY `ServiceOrder_passengers`.`index`";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  insert_statement[] =
  "INSERT INTO `ServiceOrder_passengers` "
  "(`object_id`, "
  "`index`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  delete_statement[] =
  "DELETE FROM `ServiceOrder_passengers` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::passengers_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // stops
  //

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  select_statement[] =
  "SELECT "
  "`ServiceOrder_stops`.`index`, "
  "`ServiceOrder_stops`.`value` "
  "FROM `ServiceOrder_stops` "
  "WHERE `ServiceOrder_stops`.`object_id`=? ORDER BY `ServiceOrder_stops`.`index`";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  insert_statement[] =
  "INSERT INTO `ServiceOrder_stops` "
  "(`object_id`, "
  "`index`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  delete_statement[] =
  "DELETE FROM `ServiceOrder_stops` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::stops_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // crew
  //

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`ServiceOrder_crew`.`key`+0,' ',`ServiceOrder_crew`.`key`), "
  "`ServiceOrder_crew`.`value` "
  "FROM `ServiceOrder_crew` "
  "WHERE `ServiceOrder_crew`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  insert_statement[] =
  "INSERT INTO `ServiceOrder_crew` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  delete_statement[] =
  "DELETE FROM `ServiceOrder_crew` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::crew_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::id_type
  access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // cityid
    //
    t[1UL] = 0;

    // tag
    //
    t[2UL] = 0;

    // ordertype
    //
    t[3UL] = 0;

    // ordertimetype
    //
    t[4UL] = 0;

    // dispatcherid
    //
    t[5UL] = 0;

    // initator
    //
    t[6UL] = 0;

    // payload
    //
    if (composite_value_traits< ::taxi::Payload, id_mysql >::grow (
          i.payload_value, t + 7UL))
      grew = true;

    // stage
    //
    t[15UL] = 0;

    // created
    //
    t[16UL] = 0;

    // sheduletime
    //
    t[17UL] = 0;

    // assigned
    //
    t[18UL] = 0;

    // started
    //
    t[19UL] = 0;

    // arrived
    //
    t[20UL] = 0;

    // finished
    //
    t[21UL] = 0;

    // locstart
    //
    if (composite_value_traits< ::taxi::Location, id_mysql >::grow (
          i.locstart_value, t + 22UL))
      grew = true;

    // locfinish
    //
    if (composite_value_traits< ::taxi::Location, id_mysql >::grow (
          i.locfinish_value, t + 29UL))
      grew = true;

    // totaltimefiscal
    //
    t[36UL] = 0;

    // totaltimeactual
    //
    t[37UL] = 0;

    // sumfiscal
    //
    t[38UL] = 0;

    // sumactual
    //
    t[39UL] = 0;

    // cabclass
    //
    t[40UL] = 0;

    // paymentstate
    //
    if (t[41UL])
    {
      if (mysql::enum_traits::grow (i.paymentstate_value, i.paymentstate_size))
        grew = true;
      else
        t[41UL] = 0;
    }

    // claimstate
    //
    if (t[42UL])
    {
      if (mysql::enum_traits::grow (i.claimstate_value, i.claimstate_size))
        grew = true;
      else
        t[42UL] = 0;
    }

    // hasstops
    //
    t[43UL] = 0;

    // notes
    //
    if (t[44UL])
    {
      i.notes_value.capacity (i.notes_size);
      grew = true;
    }

    // __isset
    //
    if (t[45UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // cityid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.cityid_value;
    b[n].is_null = &i.cityid_null;
    n++;

    // tag
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.tag_value;
    b[n].is_null = &i.tag_null;
    n++;

    // ordertype
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.ordertype_value;
    b[n].is_null = &i.ordertype_null;
    n++;

    // ordertimetype
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.ordertimetype_value;
    b[n].is_null = &i.ordertimetype_null;
    n++;

    // dispatcherid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.dispatcherid_value;
    b[n].is_null = &i.dispatcherid_null;
    n++;

    // initator
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.initator_value;
    b[n].is_null = &i.initator_null;
    n++;

    // payload
    //
    composite_value_traits< ::taxi::Payload, id_mysql >::bind (
      b + n, i.payload_value, sk);
    n += 8UL;

    // stage
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.stage_value;
    b[n].is_null = &i.stage_null;
    n++;

    // created
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.created_value;
    b[n].is_null = &i.created_null;
    n++;

    // sheduletime
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.sheduletime_value;
    b[n].is_null = &i.sheduletime_null;
    n++;

    // assigned
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.assigned_value;
    b[n].is_null = &i.assigned_null;
    n++;

    // started
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.started_value;
    b[n].is_null = &i.started_null;
    n++;

    // arrived
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.arrived_value;
    b[n].is_null = &i.arrived_null;
    n++;

    // finished
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.finished_value;
    b[n].is_null = &i.finished_null;
    n++;

    // locstart
    //
    composite_value_traits< ::taxi::Location, id_mysql >::bind (
      b + n, i.locstart_value, sk);
    n += 7UL;

    // locfinish
    //
    composite_value_traits< ::taxi::Location, id_mysql >::bind (
      b + n, i.locfinish_value, sk);
    n += 7UL;

    // totaltimefiscal
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.totaltimefiscal_value;
    b[n].is_null = &i.totaltimefiscal_null;
    n++;

    // totaltimeactual
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.totaltimeactual_value;
    b[n].is_null = &i.totaltimeactual_null;
    n++;

    // sumfiscal
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.sumfiscal_value;
    b[n].is_null = &i.sumfiscal_null;
    n++;

    // sumactual
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.sumactual_value;
    b[n].is_null = &i.sumactual_null;
    n++;

    // cabclass
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &i.cabclass_value;
    b[n].is_null = &i.cabclass_null;
    n++;

    // paymentstate
    //
    mysql::enum_traits::bind (b[n],
                              i.paymentstate_value,
                              i.paymentstate_size,
                              &i.paymentstate_null);
    n++;

    // claimstate
    //
    mysql::enum_traits::bind (b[n],
                              i.claimstate_value,
                              i.claimstate_size,
                              &i.claimstate_null);
    n++;

    // hasstops
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.hasstops_value;
    b[n].is_null = &i.hasstops_null;
    n++;

    // notes
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.notes_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.notes_value.capacity ());
    b[n].length = &i.notes_size;
    b[n].is_null = &i.notes_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // cityid
    //
    {
      ::taxi::ID const& v =
        o.cityid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.cityid_value, is_null, v);
      i.cityid_null = is_null;
    }

    // tag
    //
    {
      ::taxi::NUMBER32 const& v =
        o.tag;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.tag_value, is_null, v);
      i.tag_null = is_null;
    }

    // ordertype
    //
    {
      ::taxi::OrderType::type const& v =
        o.ordertype;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::OrderType::type,
          mysql::id_ulong >::set_image (
        i.ordertype_value, is_null, v);
      i.ordertype_null = is_null;
    }

    // ordertimetype
    //
    {
      ::taxi::OrderTimeType::type const& v =
        o.ordertimetype;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::OrderTimeType::type,
          mysql::id_ulong >::set_image (
        i.ordertimetype_value, is_null, v);
      i.ordertimetype_null = is_null;
    }

    // dispatcherid
    //
    {
      ::taxi::ID const& v =
        o.dispatcherid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.dispatcherid_value, is_null, v);
      i.dispatcherid_null = is_null;
    }

    // initator
    //
    {
      ::taxi::Personid const& v =
        o.initator;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::Personid,
          mysql::id_longlong >::set_image (
        i.initator_value, is_null, v);
      i.initator_null = is_null;
    }

    // payload
    //
    {
      ::taxi::Payload const& v =
        o.payload;

      if (composite_value_traits< ::taxi::Payload, id_mysql >::init (
            i.payload_value,
            v,
            sk))
        grew = true;
    }

    // stage
    //
    {
      ::taxi::OrderStage::type const& v =
        o.stage;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::OrderStage::type,
          mysql::id_ulong >::set_image (
        i.stage_value, is_null, v);
      i.stage_null = is_null;
    }

    // created
    //
    {
      ::taxi::DATE const& v =
        o.created;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.created_value, is_null, v);
      i.created_null = is_null;
    }

    // sheduletime
    //
    {
      ::taxi::DATE const& v =
        o.sheduletime;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.sheduletime_value, is_null, v);
      i.sheduletime_null = is_null;
    }

    // assigned
    //
    {
      ::taxi::DATE const& v =
        o.assigned;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.assigned_value, is_null, v);
      i.assigned_null = is_null;
    }

    // started
    //
    {
      ::taxi::DATE const& v =
        o.started;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.started_value, is_null, v);
      i.started_null = is_null;
    }

    // arrived
    //
    {
      ::taxi::DATE const& v =
        o.arrived;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.arrived_value, is_null, v);
      i.arrived_null = is_null;
    }

    // finished
    //
    {
      ::taxi::DATE const& v =
        o.finished;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.finished_value, is_null, v);
      i.finished_null = is_null;
    }

    // locstart
    //
    {
      ::taxi::Location const& v =
        o.locstart;

      if (composite_value_traits< ::taxi::Location, id_mysql >::init (
            i.locstart_value,
            v,
            sk))
        grew = true;
    }

    // locfinish
    //
    {
      ::taxi::Location const& v =
        o.locfinish;

      if (composite_value_traits< ::taxi::Location, id_mysql >::init (
            i.locfinish_value,
            v,
            sk))
        grew = true;
    }

    // totaltimefiscal
    //
    {
      ::taxi::NUMBER32 const& v =
        o.totaltimefiscal;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.totaltimefiscal_value, is_null, v);
      i.totaltimefiscal_null = is_null;
    }

    // totaltimeactual
    //
    {
      ::taxi::NUMBER32 const& v =
        o.totaltimeactual;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.totaltimeactual_value, is_null, v);
      i.totaltimeactual_null = is_null;
    }

    // sumfiscal
    //
    {
      ::taxi::CURR const& v =
        o.sumfiscal;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.sumfiscal_value, is_null, v);
      i.sumfiscal_null = is_null;
    }

    // sumactual
    //
    {
      ::taxi::CURR const& v =
        o.sumactual;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.sumactual_value, is_null, v);
      i.sumactual_null = is_null;
    }

    // cabclass
    //
    {
      ::taxi::CabClass::type const& v =
        o.cabclass;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CabClass::type,
          mysql::id_ulong >::set_image (
        i.cabclass_value, is_null, v);
      i.cabclass_null = is_null;
    }

    // paymentstate
    //
    {
      ::taxi::PaymentState::type const& v =
        o.paymentstate;

      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.paymentstate_value,
            i.paymentstate_size,
            is_null,
            v))
        grew = true;

      i.paymentstate_null = is_null;
    }

    // claimstate
    //
    {
      ::taxi::ClaimState::type const& v =
        o.claimstate;

      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.claimstate_value,
            i.claimstate_size,
            is_null,
            v))
        grew = true;

      i.claimstate_null = is_null;
    }

    // hasstops
    //
    {
      bool const& v =
        o.hasstops;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.hasstops_value, is_null, v);
      i.hasstops_null = is_null;
    }

    // notes
    //
    {
      ::taxi::STR const& v =
        o.notes;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.notes_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.notes_value,
        size,
        is_null,
        v);
      i.notes_null = is_null;
      i.notes_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.notes_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_ServiceOrder__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_ServiceOrder__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // cityid
    //
    {
      ::taxi::ID& v =
        o.cityid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.cityid_value,
        i.cityid_null);
    }

    // tag
    //
    {
      ::taxi::NUMBER32& v =
        o.tag;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.tag_value,
        i.tag_null);
    }

    // ordertype
    //
    {
      ::taxi::OrderType::type& v =
        o.ordertype;

      mysql::value_traits<
          ::taxi::OrderType::type,
          mysql::id_ulong >::set_value (
        v,
        i.ordertype_value,
        i.ordertype_null);
    }

    // ordertimetype
    //
    {
      ::taxi::OrderTimeType::type& v =
        o.ordertimetype;

      mysql::value_traits<
          ::taxi::OrderTimeType::type,
          mysql::id_ulong >::set_value (
        v,
        i.ordertimetype_value,
        i.ordertimetype_null);
    }

    // dispatcherid
    //
    {
      ::taxi::ID& v =
        o.dispatcherid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.dispatcherid_value,
        i.dispatcherid_null);
    }

    // initator
    //
    {
      ::taxi::Personid& v =
        o.initator;

      mysql::value_traits<
          ::taxi::Personid,
          mysql::id_longlong >::set_value (
        v,
        i.initator_value,
        i.initator_null);
    }

    // payload
    //
    {
      ::taxi::Payload& v =
        o.payload;

      composite_value_traits< ::taxi::Payload, id_mysql >::init (
        v,
        i.payload_value,
        db);
    }

    // stage
    //
    {
      ::taxi::OrderStage::type& v =
        o.stage;

      mysql::value_traits<
          ::taxi::OrderStage::type,
          mysql::id_ulong >::set_value (
        v,
        i.stage_value,
        i.stage_null);
    }

    // created
    //
    {
      ::taxi::DATE& v =
        o.created;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.created_value,
        i.created_null);
    }

    // sheduletime
    //
    {
      ::taxi::DATE& v =
        o.sheduletime;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.sheduletime_value,
        i.sheduletime_null);
    }

    // assigned
    //
    {
      ::taxi::DATE& v =
        o.assigned;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.assigned_value,
        i.assigned_null);
    }

    // started
    //
    {
      ::taxi::DATE& v =
        o.started;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.started_value,
        i.started_null);
    }

    // arrived
    //
    {
      ::taxi::DATE& v =
        o.arrived;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.arrived_value,
        i.arrived_null);
    }

    // finished
    //
    {
      ::taxi::DATE& v =
        o.finished;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.finished_value,
        i.finished_null);
    }

    // locstart
    //
    {
      ::taxi::Location& v =
        o.locstart;

      composite_value_traits< ::taxi::Location, id_mysql >::init (
        v,
        i.locstart_value,
        db);
    }

    // locfinish
    //
    {
      ::taxi::Location& v =
        o.locfinish;

      composite_value_traits< ::taxi::Location, id_mysql >::init (
        v,
        i.locfinish_value,
        db);
    }

    // totaltimefiscal
    //
    {
      ::taxi::NUMBER32& v =
        o.totaltimefiscal;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.totaltimefiscal_value,
        i.totaltimefiscal_null);
    }

    // totaltimeactual
    //
    {
      ::taxi::NUMBER32& v =
        o.totaltimeactual;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.totaltimeactual_value,
        i.totaltimeactual_null);
    }

    // sumfiscal
    //
    {
      ::taxi::CURR& v =
        o.sumfiscal;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.sumfiscal_value,
        i.sumfiscal_null);
    }

    // sumactual
    //
    {
      ::taxi::CURR& v =
        o.sumactual;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.sumactual_value,
        i.sumactual_null);
    }

    // cabclass
    //
    {
      ::taxi::CabClass::type& v =
        o.cabclass;

      mysql::value_traits<
          ::taxi::CabClass::type,
          mysql::id_ulong >::set_value (
        v,
        i.cabclass_value,
        i.cabclass_null);
    }

    // paymentstate
    //
    {
      ::taxi::PaymentState::type& v =
        o.paymentstate;

      mysql::enum_traits::set_value (
        v,
        i.paymentstate_value,
        i.paymentstate_size,
        i.paymentstate_null);
    }

    // claimstate
    //
    {
      ::taxi::ClaimState::type& v =
        o.claimstate;

      mysql::enum_traits::set_value (
        v,
        i.claimstate_value,
        i.claimstate_size,
        i.claimstate_null);
    }

    // hasstops
    //
    {
      bool& v =
        o.hasstops;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.hasstops_value,
        i.hasstops_null);
    }

    // notes
    //
    {
      ::taxi::STR& v =
        o.notes;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.notes_value,
        i.notes_size,
        i.notes_null);
    }

    // __isset
    //
    {
      ::taxi::_ServiceOrder__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_ServiceOrder__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::persist_statement[] =
  "INSERT INTO `ServiceOrder` "
  "(`id`, "
  "`cityid`, "
  "`tag`, "
  "`ordertype`, "
  "`ordertimetype`, "
  "`dispatcherid`, "
  "`initator`, "
  "`payload_passengercount`, "
  "`payload_baggagecount`, "
  "`payload_baggageweight`, "
  "`payload_baggagewidth`, "
  "`payload_baggageheight`, "
  "`payload_papercount`, "
  "`payload_stopcount`, "
  "`payload_isset`, "
  "`stage`, "
  "`created`, "
  "`sheduletime`, "
  "`assigned`, "
  "`started`, "
  "`arrived`, "
  "`finished`, "
  "`locstart_location_latitude`, "
  "`locstart_location_longitude`, "
  "`locstart_location_isset`, "
  "`locstart_name`, "
  "`locstart_city`, "
  "`locstart_address`, "
  "`locstart_isset`, "
  "`locfinish_location_latitude`, "
  "`locfinish_location_longitude`, "
  "`locfinish_location_isset`, "
  "`locfinish_name`, "
  "`locfinish_city`, "
  "`locfinish_address`, "
  "`locfinish_isset`, "
  "`totaltimefiscal`, "
  "`totaltimeactual`, "
  "`sumfiscal`, "
  "`sumactual`, "
  "`cabclass`, "
  "`paymentstate`, "
  "`claimstate`, "
  "`hasstops`, "
  "`notes`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::find_statement[] =
  "SELECT "
  "`ServiceOrder`.`id`, "
  "`ServiceOrder`.`cityid`, "
  "`ServiceOrder`.`tag`, "
  "`ServiceOrder`.`ordertype`, "
  "`ServiceOrder`.`ordertimetype`, "
  "`ServiceOrder`.`dispatcherid`, "
  "`ServiceOrder`.`initator`, "
  "`ServiceOrder`.`payload_passengercount`, "
  "`ServiceOrder`.`payload_baggagecount`, "
  "`ServiceOrder`.`payload_baggageweight`, "
  "`ServiceOrder`.`payload_baggagewidth`, "
  "`ServiceOrder`.`payload_baggageheight`, "
  "`ServiceOrder`.`payload_papercount`, "
  "`ServiceOrder`.`payload_stopcount`, "
  "`ServiceOrder`.`payload_isset`, "
  "`ServiceOrder`.`stage`, "
  "`ServiceOrder`.`created`, "
  "`ServiceOrder`.`sheduletime`, "
  "`ServiceOrder`.`assigned`, "
  "`ServiceOrder`.`started`, "
  "`ServiceOrder`.`arrived`, "
  "`ServiceOrder`.`finished`, "
  "`ServiceOrder`.`locstart_location_latitude`, "
  "`ServiceOrder`.`locstart_location_longitude`, "
  "`ServiceOrder`.`locstart_location_isset`, "
  "`ServiceOrder`.`locstart_name`, "
  "`ServiceOrder`.`locstart_city`, "
  "`ServiceOrder`.`locstart_address`, "
  "`ServiceOrder`.`locstart_isset`, "
  "`ServiceOrder`.`locfinish_location_latitude`, "
  "`ServiceOrder`.`locfinish_location_longitude`, "
  "`ServiceOrder`.`locfinish_location_isset`, "
  "`ServiceOrder`.`locfinish_name`, "
  "`ServiceOrder`.`locfinish_city`, "
  "`ServiceOrder`.`locfinish_address`, "
  "`ServiceOrder`.`locfinish_isset`, "
  "`ServiceOrder`.`totaltimefiscal`, "
  "`ServiceOrder`.`totaltimeactual`, "
  "`ServiceOrder`.`sumfiscal`, "
  "`ServiceOrder`.`sumactual`, "
  "`ServiceOrder`.`cabclass`, "
  "CONCAT(`ServiceOrder`.`paymentstate`+0,' ',`ServiceOrder`.`paymentstate`), "
  "CONCAT(`ServiceOrder`.`claimstate`+0,' ',`ServiceOrder`.`claimstate`), "
  "`ServiceOrder`.`hasstops`, "
  "`ServiceOrder`.`notes`, "
  "`ServiceOrder`.`isset` "
  "FROM `ServiceOrder` "
  "WHERE `ServiceOrder`.`id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::update_statement[] =
  "UPDATE `ServiceOrder` "
  "SET "
  "`cityid`=?, "
  "`tag`=?, "
  "`ordertype`=?, "
  "`ordertimetype`=?, "
  "`dispatcherid`=?, "
  "`initator`=?, "
  "`payload_passengercount`=?, "
  "`payload_baggagecount`=?, "
  "`payload_baggageweight`=?, "
  "`payload_baggagewidth`=?, "
  "`payload_baggageheight`=?, "
  "`payload_papercount`=?, "
  "`payload_stopcount`=?, "
  "`payload_isset`=?, "
  "`stage`=?, "
  "`created`=?, "
  "`sheduletime`=?, "
  "`assigned`=?, "
  "`started`=?, "
  "`arrived`=?, "
  "`finished`=?, "
  "`locstart_location_latitude`=?, "
  "`locstart_location_longitude`=?, "
  "`locstart_location_isset`=?, "
  "`locstart_name`=?, "
  "`locstart_city`=?, "
  "`locstart_address`=?, "
  "`locstart_isset`=?, "
  "`locfinish_location_latitude`=?, "
  "`locfinish_location_longitude`=?, "
  "`locfinish_location_isset`=?, "
  "`locfinish_name`=?, "
  "`locfinish_city`=?, "
  "`locfinish_address`=?, "
  "`locfinish_isset`=?, "
  "`totaltimefiscal`=?, "
  "`totaltimeactual`=?, "
  "`sumfiscal`=?, "
  "`sumactual`=?, "
  "`cabclass`=?, "
  "`paymentstate`=?, "
  "`claimstate`=?, "
  "`hasstops`=?, "
  "`notes`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::erase_statement[] =
  "DELETE FROM `ServiceOrder` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::query_statement[] =
  "SELECT "
  "`ServiceOrder`.`id`, "
  "`ServiceOrder`.`cityid`, "
  "`ServiceOrder`.`tag`, "
  "`ServiceOrder`.`ordertype`, "
  "`ServiceOrder`.`ordertimetype`, "
  "`ServiceOrder`.`dispatcherid`, "
  "`ServiceOrder`.`initator`, "
  "`ServiceOrder`.`payload_passengercount`, "
  "`ServiceOrder`.`payload_baggagecount`, "
  "`ServiceOrder`.`payload_baggageweight`, "
  "`ServiceOrder`.`payload_baggagewidth`, "
  "`ServiceOrder`.`payload_baggageheight`, "
  "`ServiceOrder`.`payload_papercount`, "
  "`ServiceOrder`.`payload_stopcount`, "
  "`ServiceOrder`.`payload_isset`, "
  "`ServiceOrder`.`stage`, "
  "`ServiceOrder`.`created`, "
  "`ServiceOrder`.`sheduletime`, "
  "`ServiceOrder`.`assigned`, "
  "`ServiceOrder`.`started`, "
  "`ServiceOrder`.`arrived`, "
  "`ServiceOrder`.`finished`, "
  "`ServiceOrder`.`locstart_location_latitude`, "
  "`ServiceOrder`.`locstart_location_longitude`, "
  "`ServiceOrder`.`locstart_location_isset`, "
  "`ServiceOrder`.`locstart_name`, "
  "`ServiceOrder`.`locstart_city`, "
  "`ServiceOrder`.`locstart_address`, "
  "`ServiceOrder`.`locstart_isset`, "
  "`ServiceOrder`.`locfinish_location_latitude`, "
  "`ServiceOrder`.`locfinish_location_longitude`, "
  "`ServiceOrder`.`locfinish_location_isset`, "
  "`ServiceOrder`.`locfinish_name`, "
  "`ServiceOrder`.`locfinish_city`, "
  "`ServiceOrder`.`locfinish_address`, "
  "`ServiceOrder`.`locfinish_isset`, "
  "`ServiceOrder`.`totaltimefiscal`, "
  "`ServiceOrder`.`totaltimeactual`, "
  "`ServiceOrder`.`sumfiscal`, "
  "`ServiceOrder`.`sumactual`, "
  "`ServiceOrder`.`cabclass`, "
  "CONCAT(`ServiceOrder`.`paymentstate`+0,' ',`ServiceOrder`.`paymentstate`), "
  "CONCAT(`ServiceOrder`.`claimstate`+0,' ',`ServiceOrder`.`claimstate`), "
  "`ServiceOrder`.`hasstops`, "
  "`ServiceOrder`.`notes`, "
  "`ServiceOrder`.`isset` "
  "FROM `ServiceOrder`";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::erase_query_statement[] =
  "DELETE FROM `ServiceOrder`";

  const char access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::table_name[] =
  "`ServiceOrder`";

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orderfeatures
    //
    {
      ::taxi::OrderFeatures const& v =
        obj.orderfeatures;

      orderfeatures_traits::persist (
        v,
        esc.orderfeatures);
    }

    // svc
    //
    {
      ::taxi::RoleOrgService const& v =
        obj.svc;

      svc_traits::persist (
        v,
        esc.svc);
    }

    // passengers
    //
    {
      ::taxi::Passengerids const& v =
        obj.passengers;

      passengers_traits::persist (
        v,
        esc.passengers);
    }

    // stops
    //
    {
      ::taxi::ServiceOrderStopids const& v =
        obj.stops;

      stops_traits::persist (
        v,
        esc.stops);
    }

    // crew
    //
    {
      ::taxi::Crew const& v =
        obj.crew;

      crew_traits::persist (
        v,
        esc.crew);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orderfeatures
    //
    {
      ::taxi::OrderFeatures const& v =
        obj.orderfeatures;

      orderfeatures_traits::update (
        v,
        esc.orderfeatures);
    }

    // svc
    //
    {
      ::taxi::RoleOrgService const& v =
        obj.svc;

      svc_traits::update (
        v,
        esc.svc);
    }

    // passengers
    //
    {
      ::taxi::Passengerids const& v =
        obj.passengers;

      passengers_traits::update (
        v,
        esc.passengers);
    }

    // stops
    //
    {
      ::taxi::ServiceOrderStopids const& v =
        obj.stops;

      stops_traits::update (
        v,
        esc.stops);
    }

    // crew
    //
    {
      ::taxi::Crew const& v =
        obj.crew;

      crew_traits::update (
        v,
        esc.crew);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orderfeatures
    //
    orderfeatures_traits::erase (
      esc.orderfeatures);

    // svc
    //
    svc_traits::erase (
      esc.svc);

    // passengers
    //
    passengers_traits::erase (
      esc.passengers);

    // stops
    //
    stops_traits::erase (
      esc.stops);

    // crew
    //
    crew_traits::erase (
      esc.crew);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orderfeatures
    //
    {
      ::taxi::OrderFeatures& v =
        obj.orderfeatures;

      orderfeatures_traits::load (
        v,
        esc.orderfeatures);
    }

    // svc
    //
    {
      ::taxi::RoleOrgService& v =
        obj.svc;

      svc_traits::load (
        v,
        esc.svc);
    }

    // passengers
    //
    {
      ::taxi::Passengerids& v =
        obj.passengers;

      passengers_traits::load (
        v,
        esc.passengers);
    }

    // stops
    //
    {
      ::taxi::ServiceOrderStopids& v =
        obj.stops;

      stops_traits::load (
        v,
        esc.stops);
    }

    // crew
    //
    {
      ::taxi::Crew& v =
        obj.crew;

      crew_traits::load (
        v,
        esc.crew);
    }
  }

  result< access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::ServiceOrder, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // ServiceOrderDecline
  //

  struct access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::id_type
  access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // serviceorderid
    //
    t[1UL] = 0;

    // declinetime
    //
    t[2UL] = 0;

    // driverid
    //
    t[3UL] = 0;

    // cause
    //
    if (t[4UL])
    {
      if (mysql::enum_traits::grow (i.cause_value, i.cause_size))
        grew = true;
      else
        t[4UL] = 0;
    }

    // notes
    //
    if (t[5UL])
    {
      i.notes_value.capacity (i.notes_size);
      grew = true;
    }

    // __isset
    //
    if (t[6UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // serviceorderid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.serviceorderid_value;
    b[n].is_null = &i.serviceorderid_null;
    n++;

    // declinetime
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.declinetime_value;
    b[n].is_null = &i.declinetime_null;
    n++;

    // driverid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.driverid_value;
    b[n].is_null = &i.driverid_null;
    n++;

    // cause
    //
    mysql::enum_traits::bind (b[n],
                              i.cause_value,
                              i.cause_size,
                              &i.cause_null);
    n++;

    // notes
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.notes_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.notes_value.capacity ());
    b[n].length = &i.notes_size;
    b[n].is_null = &i.notes_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // serviceorderid
    //
    {
      ::taxi::Serviceorderid const& v =
        o.serviceorderid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::Serviceorderid,
          mysql::id_longlong >::set_image (
        i.serviceorderid_value, is_null, v);
      i.serviceorderid_null = is_null;
    }

    // declinetime
    //
    {
      ::taxi::DATE const& v =
        o.declinetime;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.declinetime_value, is_null, v);
      i.declinetime_null = is_null;
    }

    // driverid
    //
    {
      ::taxi::Driverid const& v =
        o.driverid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::Driverid,
          mysql::id_longlong >::set_image (
        i.driverid_value, is_null, v);
      i.driverid_null = is_null;
    }

    // cause
    //
    {
      ::taxi::DeclineOrderCause::type const& v =
        o.cause;

      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.cause_value,
            i.cause_size,
            is_null,
            v))
        grew = true;

      i.cause_null = is_null;
    }

    // notes
    //
    {
      ::taxi::STR const& v =
        o.notes;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.notes_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.notes_value,
        size,
        is_null,
        v);
      i.notes_null = is_null;
      i.notes_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.notes_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_ServiceOrderDecline__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_ServiceOrderDecline__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // serviceorderid
    //
    {
      ::taxi::Serviceorderid& v =
        o.serviceorderid;

      mysql::value_traits<
          ::taxi::Serviceorderid,
          mysql::id_longlong >::set_value (
        v,
        i.serviceorderid_value,
        i.serviceorderid_null);
    }

    // declinetime
    //
    {
      ::taxi::DATE& v =
        o.declinetime;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.declinetime_value,
        i.declinetime_null);
    }

    // driverid
    //
    {
      ::taxi::Driverid& v =
        o.driverid;

      mysql::value_traits<
          ::taxi::Driverid,
          mysql::id_longlong >::set_value (
        v,
        i.driverid_value,
        i.driverid_null);
    }

    // cause
    //
    {
      ::taxi::DeclineOrderCause::type& v =
        o.cause;

      mysql::enum_traits::set_value (
        v,
        i.cause_value,
        i.cause_size,
        i.cause_null);
    }

    // notes
    //
    {
      ::taxi::STR& v =
        o.notes;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.notes_value,
        i.notes_size,
        i.notes_null);
    }

    // __isset
    //
    {
      ::taxi::_ServiceOrderDecline__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_ServiceOrderDecline__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::persist_statement[] =
  "INSERT INTO `ServiceOrderDecline` "
  "(`id`, "
  "`serviceorderid`, "
  "`declinetime`, "
  "`driverid`, "
  "`cause`, "
  "`notes`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::find_statement[] =
  "SELECT "
  "`ServiceOrderDecline`.`id`, "
  "`ServiceOrderDecline`.`serviceorderid`, "
  "`ServiceOrderDecline`.`declinetime`, "
  "`ServiceOrderDecline`.`driverid`, "
  "CONCAT(`ServiceOrderDecline`.`cause`+0,' ',`ServiceOrderDecline`.`cause`), "
  "`ServiceOrderDecline`.`notes`, "
  "`ServiceOrderDecline`.`isset` "
  "FROM `ServiceOrderDecline` "
  "WHERE `ServiceOrderDecline`.`id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::update_statement[] =
  "UPDATE `ServiceOrderDecline` "
  "SET "
  "`serviceorderid`=?, "
  "`declinetime`=?, "
  "`driverid`=?, "
  "`cause`=?, "
  "`notes`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::erase_statement[] =
  "DELETE FROM `ServiceOrderDecline` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::query_statement[] =
  "SELECT "
  "`ServiceOrderDecline`.`id`, "
  "`ServiceOrderDecline`.`serviceorderid`, "
  "`ServiceOrderDecline`.`declinetime`, "
  "`ServiceOrderDecline`.`driverid`, "
  "CONCAT(`ServiceOrderDecline`.`cause`+0,' ',`ServiceOrderDecline`.`cause`), "
  "`ServiceOrderDecline`.`notes`, "
  "`ServiceOrderDecline`.`isset` "
  "FROM `ServiceOrderDecline`";

  const char access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::erase_query_statement[] =
  "DELETE FROM `ServiceOrderDecline`";

  const char access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::table_name[] =
  "`ServiceOrderDecline`";

  void access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::ServiceOrderDecline, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Claim
  //

  struct access::object_traits_impl< ::taxi::Claim, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::Claim, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Claim, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Claim, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // serviceorderid
    //
    t[1UL] = 0;

    // personrole
    //
    if (t[2UL])
    {
      if (mysql::enum_traits::grow (i.personrole_value, i.personrole_size))
        grew = true;
      else
        t[2UL] = 0;
    }

    // driverid
    //
    t[3UL] = 0;

    // claimtime
    //
    t[4UL] = 0;

    // notes
    //
    if (t[5UL])
    {
      i.notes_value.capacity (i.notes_size);
      grew = true;
    }

    // __isset
    //
    if (t[6UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Claim, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // serviceorderid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.serviceorderid_value;
    b[n].is_null = &i.serviceorderid_null;
    n++;

    // personrole
    //
    mysql::enum_traits::bind (b[n],
                              i.personrole_value,
                              i.personrole_size,
                              &i.personrole_null);
    n++;

    // driverid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.driverid_value;
    b[n].is_null = &i.driverid_null;
    n++;

    // claimtime
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.claimtime_value;
    b[n].is_null = &i.claimtime_null;
    n++;

    // notes
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.notes_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.notes_value.capacity ());
    b[n].length = &i.notes_size;
    b[n].is_null = &i.notes_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Claim, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Claim, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // serviceorderid
    //
    {
      ::taxi::Serviceorderid const& v =
        o.serviceorderid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::Serviceorderid,
          mysql::id_longlong >::set_image (
        i.serviceorderid_value, is_null, v);
      i.serviceorderid_null = is_null;
    }

    // personrole
    //
    {
      ::taxi::PersonRole::type const& v =
        o.personrole;

      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.personrole_value,
            i.personrole_size,
            is_null,
            v))
        grew = true;

      i.personrole_null = is_null;
    }

    // driverid
    //
    {
      ::taxi::Driverid const& v =
        o.driverid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::Driverid,
          mysql::id_longlong >::set_image (
        i.driverid_value, is_null, v);
      i.driverid_null = is_null;
    }

    // claimtime
    //
    {
      ::taxi::DATE const& v =
        o.claimtime;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.claimtime_value, is_null, v);
      i.claimtime_null = is_null;
    }

    // notes
    //
    {
      ::taxi::STR const& v =
        o.notes;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.notes_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.notes_value,
        size,
        is_null,
        v);
      i.notes_null = is_null;
      i.notes_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.notes_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_Claim__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Claim__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Claim, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // serviceorderid
    //
    {
      ::taxi::Serviceorderid& v =
        o.serviceorderid;

      mysql::value_traits<
          ::taxi::Serviceorderid,
          mysql::id_longlong >::set_value (
        v,
        i.serviceorderid_value,
        i.serviceorderid_null);
    }

    // personrole
    //
    {
      ::taxi::PersonRole::type& v =
        o.personrole;

      mysql::enum_traits::set_value (
        v,
        i.personrole_value,
        i.personrole_size,
        i.personrole_null);
    }

    // driverid
    //
    {
      ::taxi::Driverid& v =
        o.driverid;

      mysql::value_traits<
          ::taxi::Driverid,
          mysql::id_longlong >::set_value (
        v,
        i.driverid_value,
        i.driverid_null);
    }

    // claimtime
    //
    {
      ::taxi::DATE& v =
        o.claimtime;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.claimtime_value,
        i.claimtime_null);
    }

    // notes
    //
    {
      ::taxi::STR& v =
        o.notes;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.notes_value,
        i.notes_size,
        i.notes_null);
    }

    // __isset
    //
    {
      ::taxi::_Claim__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Claim__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Claim, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Claim, id_mysql >::persist_statement[] =
  "INSERT INTO `Claim` "
  "(`id`, "
  "`serviceorderid`, "
  "`personrole`, "
  "`driverid`, "
  "`claimtime`, "
  "`notes`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Claim, id_mysql >::find_statement[] =
  "SELECT "
  "`Claim`.`id`, "
  "`Claim`.`serviceorderid`, "
  "CONCAT(`Claim`.`personrole`+0,' ',`Claim`.`personrole`), "
  "`Claim`.`driverid`, "
  "`Claim`.`claimtime`, "
  "`Claim`.`notes`, "
  "`Claim`.`isset` "
  "FROM `Claim` "
  "WHERE `Claim`.`id`=?";

  const char access::object_traits_impl< ::taxi::Claim, id_mysql >::update_statement[] =
  "UPDATE `Claim` "
  "SET "
  "`serviceorderid`=?, "
  "`personrole`=?, "
  "`driverid`=?, "
  "`claimtime`=?, "
  "`notes`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Claim, id_mysql >::erase_statement[] =
  "DELETE FROM `Claim` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Claim, id_mysql >::query_statement[] =
  "SELECT "
  "`Claim`.`id`, "
  "`Claim`.`serviceorderid`, "
  "CONCAT(`Claim`.`personrole`+0,' ',`Claim`.`personrole`), "
  "`Claim`.`driverid`, "
  "`Claim`.`claimtime`, "
  "`Claim`.`notes`, "
  "`Claim`.`isset` "
  "FROM `Claim`";

  const char access::object_traits_impl< ::taxi::Claim, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Claim`";

  const char access::object_traits_impl< ::taxi::Claim, id_mysql >::table_name[] =
  "`Claim`";

  void access::object_traits_impl< ::taxi::Claim, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Claim, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Claim, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Claim, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Claim, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Claim, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Claim, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Claim, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::Claim, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Claim, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Claim, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Track
  //

  struct access::object_traits_impl< ::taxi::Track, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::Track, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Track, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Track, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // driverid
    //
    t[1UL] = 0;

    // serviceorderid
    //
    t[2UL] = 0;

    // tracktime
    //
    t[3UL] = 0;

    // location
    //
    if (composite_value_traits< ::taxi::GeoLocation, id_mysql >::grow (
          i.location_value, t + 4UL))
      grew = true;

    // __isset
    //
    if (t[7UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Track, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // driverid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.driverid_value;
    b[n].is_null = &i.driverid_null;
    n++;

    // serviceorderid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.serviceorderid_value;
    b[n].is_null = &i.serviceorderid_null;
    n++;

    // tracktime
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.tracktime_value;
    b[n].is_null = &i.tracktime_null;
    n++;

    // location
    //
    composite_value_traits< ::taxi::GeoLocation, id_mysql >::bind (
      b + n, i.location_value, sk);
    n += 3UL;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Track, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Track, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // driverid
    //
    {
      ::taxi::Driverid const& v =
        o.driverid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::Driverid,
          mysql::id_longlong >::set_image (
        i.driverid_value, is_null, v);
      i.driverid_null = is_null;
    }

    // serviceorderid
    //
    {
      ::taxi::Serviceorderid const& v =
        o.serviceorderid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::Serviceorderid,
          mysql::id_longlong >::set_image (
        i.serviceorderid_value, is_null, v);
      i.serviceorderid_null = is_null;
    }

    // tracktime
    //
    {
      ::taxi::DATE const& v =
        o.tracktime;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.tracktime_value, is_null, v);
      i.tracktime_null = is_null;
    }

    // location
    //
    {
      ::taxi::GeoLocation const& v =
        o.location;

      if (composite_value_traits< ::taxi::GeoLocation, id_mysql >::init (
            i.location_value,
            v,
            sk))
        grew = true;
    }

    // __isset
    //
    {
      ::taxi::_Track__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Track__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Track, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // driverid
    //
    {
      ::taxi::Driverid& v =
        o.driverid;

      mysql::value_traits<
          ::taxi::Driverid,
          mysql::id_longlong >::set_value (
        v,
        i.driverid_value,
        i.driverid_null);
    }

    // serviceorderid
    //
    {
      ::taxi::Serviceorderid& v =
        o.serviceorderid;

      mysql::value_traits<
          ::taxi::Serviceorderid,
          mysql::id_longlong >::set_value (
        v,
        i.serviceorderid_value,
        i.serviceorderid_null);
    }

    // tracktime
    //
    {
      ::taxi::DATE& v =
        o.tracktime;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.tracktime_value,
        i.tracktime_null);
    }

    // location
    //
    {
      ::taxi::GeoLocation& v =
        o.location;

      composite_value_traits< ::taxi::GeoLocation, id_mysql >::init (
        v,
        i.location_value,
        db);
    }

    // __isset
    //
    {
      ::taxi::_Track__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Track__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Track, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Track, id_mysql >::persist_statement[] =
  "INSERT INTO `Track` "
  "(`id`, "
  "`driverid`, "
  "`serviceorderid`, "
  "`tracktime`, "
  "`location_latitude`, "
  "`location_longitude`, "
  "`location_isset`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Track, id_mysql >::find_statement[] =
  "SELECT "
  "`Track`.`id`, "
  "`Track`.`driverid`, "
  "`Track`.`serviceorderid`, "
  "`Track`.`tracktime`, "
  "`Track`.`location_latitude`, "
  "`Track`.`location_longitude`, "
  "`Track`.`location_isset`, "
  "`Track`.`isset` "
  "FROM `Track` "
  "WHERE `Track`.`id`=?";

  const char access::object_traits_impl< ::taxi::Track, id_mysql >::update_statement[] =
  "UPDATE `Track` "
  "SET "
  "`driverid`=?, "
  "`serviceorderid`=?, "
  "`tracktime`=?, "
  "`location_latitude`=?, "
  "`location_longitude`=?, "
  "`location_isset`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Track, id_mysql >::erase_statement[] =
  "DELETE FROM `Track` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Track, id_mysql >::query_statement[] =
  "SELECT "
  "`Track`.`id`, "
  "`Track`.`driverid`, "
  "`Track`.`serviceorderid`, "
  "`Track`.`tracktime`, "
  "`Track`.`location_latitude`, "
  "`Track`.`location_longitude`, "
  "`Track`.`location_isset`, "
  "`Track`.`isset` "
  "FROM `Track`";

  const char access::object_traits_impl< ::taxi::Track, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Track`";

  const char access::object_traits_impl< ::taxi::Track, id_mysql >::table_name[] =
  "`Track`";

  void access::object_traits_impl< ::taxi::Track, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Track, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Track, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Track, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Track, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Track, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Track, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Track, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::Track, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Track, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Track, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // SheduleDays
  //

  bool access::composite_value_traits< ::taxi::SheduleDays, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // week0
    //
    t[0UL] = 0;

    // week1
    //
    t[1UL] = 0;

    // week2
    //
    t[2UL] = 0;

    // week3
    //
    t[3UL] = 0;

    // week4
    //
    t[4UL] = 0;

    // week5
    //
    t[5UL] = 0;

    // week6
    //
    t[6UL] = 0;

    // __isset
    //
    if (t[7UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::SheduleDays, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // week0
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.week0_value;
    b[n].is_null = &i.week0_null;
    n++;

    // week1
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.week1_value;
    b[n].is_null = &i.week1_null;
    n++;

    // week2
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.week2_value;
    b[n].is_null = &i.week2_null;
    n++;

    // week3
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.week3_value;
    b[n].is_null = &i.week3_null;
    n++;

    // week4
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.week4_value;
    b[n].is_null = &i.week4_null;
    n++;

    // week5
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.week5_value;
    b[n].is_null = &i.week5_null;
    n++;

    // week6
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.week6_value;
    b[n].is_null = &i.week6_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  bool access::composite_value_traits< ::taxi::SheduleDays, id_mysql >::
  init (image_type& i,
        const value_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // week0
    //
    {
      bool const& v =
        o.week0;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.week0_value, is_null, v);
      i.week0_null = is_null;
    }

    // week1
    //
    {
      bool const& v =
        o.week1;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.week1_value, is_null, v);
      i.week1_null = is_null;
    }

    // week2
    //
    {
      bool const& v =
        o.week2;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.week2_value, is_null, v);
      i.week2_null = is_null;
    }

    // week3
    //
    {
      bool const& v =
        o.week3;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.week3_value, is_null, v);
      i.week3_null = is_null;
    }

    // week4
    //
    {
      bool const& v =
        o.week4;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.week4_value, is_null, v);
      i.week4_null = is_null;
    }

    // week5
    //
    {
      bool const& v =
        o.week5;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.week5_value, is_null, v);
      i.week5_null = is_null;
    }

    // week6
    //
    {
      bool const& v =
        o.week6;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.week6_value, is_null, v);
      i.week6_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_SheduleDays__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_SheduleDays__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::taxi::SheduleDays, id_mysql >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // week0
    //
    {
      bool& v =
        o.week0;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.week0_value,
        i.week0_null);
    }

    // week1
    //
    {
      bool& v =
        o.week1;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.week1_value,
        i.week1_null);
    }

    // week2
    //
    {
      bool& v =
        o.week2;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.week2_value,
        i.week2_null);
    }

    // week3
    //
    {
      bool& v =
        o.week3;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.week3_value,
        i.week3_null);
    }

    // week4
    //
    {
      bool& v =
        o.week4;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.week4_value,
        i.week4_null);
    }

    // week5
    //
    {
      bool& v =
        o.week5;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.week5_value,
        i.week5_null);
    }

    // week6
    //
    {
      bool& v =
        o.week6;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.week6_value,
        i.week6_null);
    }

    // __isset
    //
    {
      ::taxi::_SheduleDays__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_SheduleDays__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  // Shedule
  //

  struct access::object_traits_impl< ::taxi::Shedule, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< passengers_traits > passengers;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : passengers (c, id)
    {
    }
  };

  // passengers
  //

  const char access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  select_statement[] =
  "SELECT "
  "`Shedule_passengers`.`index`, "
  "`Shedule_passengers`.`value` "
  "FROM `Shedule_passengers` "
  "WHERE `Shedule_passengers`.`object_id`=? ORDER BY `Shedule_passengers`.`index`";

  const char access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  insert_statement[] =
  "INSERT INTO `Shedule_passengers` "
  "(`object_id`, "
  "`index`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  delete_statement[] =
  "DELETE FROM `Shedule_passengers` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = 0;

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_image (
        i.index_value, is_null, *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      mysql::value_traits<
          index_type,
          mysql::id_ulonglong >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::passengers_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::Shedule, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // active
    //
    t[1UL] = 0;

    // sheduledays
    //
    if (composite_value_traits< ::taxi::SheduleDays, id_mysql >::grow (
          i.sheduledays_value, t + 2UL))
      grew = true;

    // customerid
    //
    t[10UL] = 0;

    // name
    //
    if (t[11UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // description
    //
    if (t[12UL])
    {
      i.description_value.capacity (i.description_size);
      grew = true;
    }

    // pointstart
    //
    if (composite_value_traits< ::taxi::Location, id_mysql >::grow (
          i.pointstart_value, t + 13UL))
      grew = true;

    // pointfinish
    //
    if (composite_value_traits< ::taxi::Location, id_mysql >::grow (
          i.pointfinish_value, t + 20UL))
      grew = true;

    // hasMiddlePoints
    //
    t[27UL] = 0;

    // haspassenger
    //
    t[28UL] = 0;

    // timestart
    //
    t[29UL] = 0;

    // timefinish
    //
    t[30UL] = 0;

    // sheduleoperatorid
    //
    t[31UL] = 0;

    // preferreddriverid
    //
    t[32UL] = 0;

    // __isset
    //
    if (t[33UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // active
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.active_value;
    b[n].is_null = &i.active_null;
    n++;

    // sheduledays
    //
    composite_value_traits< ::taxi::SheduleDays, id_mysql >::bind (
      b + n, i.sheduledays_value, sk);
    n += 8UL;

    // customerid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.customerid_value;
    b[n].is_null = &i.customerid_null;
    n++;

    // name
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.name_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.name_value.capacity ());
    b[n].length = &i.name_size;
    b[n].is_null = &i.name_null;
    n++;

    // description
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.description_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.description_value.capacity ());
    b[n].length = &i.description_size;
    b[n].is_null = &i.description_null;
    n++;

    // pointstart
    //
    composite_value_traits< ::taxi::Location, id_mysql >::bind (
      b + n, i.pointstart_value, sk);
    n += 7UL;

    // pointfinish
    //
    composite_value_traits< ::taxi::Location, id_mysql >::bind (
      b + n, i.pointfinish_value, sk);
    n += 7UL;

    // hasMiddlePoints
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.hasMiddlePoints_value;
    b[n].is_null = &i.hasMiddlePoints_null;
    n++;

    // haspassenger
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.haspassenger_value;
    b[n].is_null = &i.haspassenger_null;
    n++;

    // timestart
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.timestart_value;
    b[n].is_null = &i.timestart_null;
    n++;

    // timefinish
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.timefinish_value;
    b[n].is_null = &i.timefinish_null;
    n++;

    // sheduleoperatorid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.sheduleoperatorid_value;
    b[n].is_null = &i.sheduleoperatorid_null;
    n++;

    // preferreddriverid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.preferreddriverid_value;
    b[n].is_null = &i.preferreddriverid_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // active
    //
    {
      bool const& v =
        o.active;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.active_value, is_null, v);
      i.active_null = is_null;
    }

    // sheduledays
    //
    {
      ::taxi::SheduleDays const& v =
        o.sheduledays;

      if (composite_value_traits< ::taxi::SheduleDays, id_mysql >::init (
            i.sheduledays_value,
            v,
            sk))
        grew = true;
    }

    // customerid
    //
    {
      ::taxi::ID const& v =
        o.customerid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.customerid_value, is_null, v);
      i.customerid_null = is_null;
    }

    // name
    //
    {
      ::taxi::STR const& v =
        o.name;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.name_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.name_value,
        size,
        is_null,
        v);
      i.name_null = is_null;
      i.name_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.name_value.capacity ());
    }

    // description
    //
    {
      ::taxi::STR const& v =
        o.description;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.description_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.description_value,
        size,
        is_null,
        v);
      i.description_null = is_null;
      i.description_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.description_value.capacity ());
    }

    // pointstart
    //
    {
      ::taxi::Location const& v =
        o.pointstart;

      if (composite_value_traits< ::taxi::Location, id_mysql >::init (
            i.pointstart_value,
            v,
            sk))
        grew = true;
    }

    // pointfinish
    //
    {
      ::taxi::Location const& v =
        o.pointfinish;

      if (composite_value_traits< ::taxi::Location, id_mysql >::init (
            i.pointfinish_value,
            v,
            sk))
        grew = true;
    }

    // hasMiddlePoints
    //
    {
      bool const& v =
        o.hasMiddlePoints;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.hasMiddlePoints_value, is_null, v);
      i.hasMiddlePoints_null = is_null;
    }

    // haspassenger
    //
    {
      bool const& v =
        o.haspassenger;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.haspassenger_value, is_null, v);
      i.haspassenger_null = is_null;
    }

    // timestart
    //
    {
      ::taxi::DATE const& v =
        o.timestart;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.timestart_value, is_null, v);
      i.timestart_null = is_null;
    }

    // timefinish
    //
    {
      ::taxi::DATE const& v =
        o.timefinish;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.timefinish_value, is_null, v);
      i.timefinish_null = is_null;
    }

    // sheduleoperatorid
    //
    {
      ::taxi::ID const& v =
        o.sheduleoperatorid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.sheduleoperatorid_value, is_null, v);
      i.sheduleoperatorid_null = is_null;
    }

    // preferreddriverid
    //
    {
      ::taxi::ID const& v =
        o.preferreddriverid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.preferreddriverid_value, is_null, v);
      i.preferreddriverid_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_Shedule__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Shedule__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // active
    //
    {
      bool& v =
        o.active;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.active_value,
        i.active_null);
    }

    // sheduledays
    //
    {
      ::taxi::SheduleDays& v =
        o.sheduledays;

      composite_value_traits< ::taxi::SheduleDays, id_mysql >::init (
        v,
        i.sheduledays_value,
        db);
    }

    // customerid
    //
    {
      ::taxi::ID& v =
        o.customerid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.customerid_value,
        i.customerid_null);
    }

    // name
    //
    {
      ::taxi::STR& v =
        o.name;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // description
    //
    {
      ::taxi::STR& v =
        o.description;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.description_value,
        i.description_size,
        i.description_null);
    }

    // pointstart
    //
    {
      ::taxi::Location& v =
        o.pointstart;

      composite_value_traits< ::taxi::Location, id_mysql >::init (
        v,
        i.pointstart_value,
        db);
    }

    // pointfinish
    //
    {
      ::taxi::Location& v =
        o.pointfinish;

      composite_value_traits< ::taxi::Location, id_mysql >::init (
        v,
        i.pointfinish_value,
        db);
    }

    // hasMiddlePoints
    //
    {
      bool& v =
        o.hasMiddlePoints;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.hasMiddlePoints_value,
        i.hasMiddlePoints_null);
    }

    // haspassenger
    //
    {
      bool& v =
        o.haspassenger;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.haspassenger_value,
        i.haspassenger_null);
    }

    // timestart
    //
    {
      ::taxi::DATE& v =
        o.timestart;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.timestart_value,
        i.timestart_null);
    }

    // timefinish
    //
    {
      ::taxi::DATE& v =
        o.timefinish;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.timefinish_value,
        i.timefinish_null);
    }

    // sheduleoperatorid
    //
    {
      ::taxi::ID& v =
        o.sheduleoperatorid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.sheduleoperatorid_value,
        i.sheduleoperatorid_null);
    }

    // preferreddriverid
    //
    {
      ::taxi::ID& v =
        o.preferreddriverid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.preferreddriverid_value,
        i.preferreddriverid_null);
    }

    // __isset
    //
    {
      ::taxi::_Shedule__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Shedule__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Shedule, id_mysql >::persist_statement[] =
  "INSERT INTO `Shedule` "
  "(`id`, "
  "`active`, "
  "`sheduledays_week0`, "
  "`sheduledays_week1`, "
  "`sheduledays_week2`, "
  "`sheduledays_week3`, "
  "`sheduledays_week4`, "
  "`sheduledays_week5`, "
  "`sheduledays_week6`, "
  "`sheduledays_isset`, "
  "`customerid`, "
  "`name`, "
  "`description`, "
  "`pointstart_location_latitude`, "
  "`pointstart_location_longitude`, "
  "`pointstart_location_isset`, "
  "`pointstart_name`, "
  "`pointstart_city`, "
  "`pointstart_address`, "
  "`pointstart_isset`, "
  "`pointfinish_location_latitude`, "
  "`pointfinish_location_longitude`, "
  "`pointfinish_location_isset`, "
  "`pointfinish_name`, "
  "`pointfinish_city`, "
  "`pointfinish_address`, "
  "`pointfinish_isset`, "
  "`hasMiddlePoints`, "
  "`haspassenger`, "
  "`timestart`, "
  "`timefinish`, "
  "`sheduleoperatorid`, "
  "`preferreddriverid`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Shedule, id_mysql >::find_statement[] =
  "SELECT "
  "`Shedule`.`id`, "
  "`Shedule`.`active`, "
  "`Shedule`.`sheduledays_week0`, "
  "`Shedule`.`sheduledays_week1`, "
  "`Shedule`.`sheduledays_week2`, "
  "`Shedule`.`sheduledays_week3`, "
  "`Shedule`.`sheduledays_week4`, "
  "`Shedule`.`sheduledays_week5`, "
  "`Shedule`.`sheduledays_week6`, "
  "`Shedule`.`sheduledays_isset`, "
  "`Shedule`.`customerid`, "
  "`Shedule`.`name`, "
  "`Shedule`.`description`, "
  "`Shedule`.`pointstart_location_latitude`, "
  "`Shedule`.`pointstart_location_longitude`, "
  "`Shedule`.`pointstart_location_isset`, "
  "`Shedule`.`pointstart_name`, "
  "`Shedule`.`pointstart_city`, "
  "`Shedule`.`pointstart_address`, "
  "`Shedule`.`pointstart_isset`, "
  "`Shedule`.`pointfinish_location_latitude`, "
  "`Shedule`.`pointfinish_location_longitude`, "
  "`Shedule`.`pointfinish_location_isset`, "
  "`Shedule`.`pointfinish_name`, "
  "`Shedule`.`pointfinish_city`, "
  "`Shedule`.`pointfinish_address`, "
  "`Shedule`.`pointfinish_isset`, "
  "`Shedule`.`hasMiddlePoints`, "
  "`Shedule`.`haspassenger`, "
  "`Shedule`.`timestart`, "
  "`Shedule`.`timefinish`, "
  "`Shedule`.`sheduleoperatorid`, "
  "`Shedule`.`preferreddriverid`, "
  "`Shedule`.`isset` "
  "FROM `Shedule` "
  "WHERE `Shedule`.`id`=?";

  const char access::object_traits_impl< ::taxi::Shedule, id_mysql >::update_statement[] =
  "UPDATE `Shedule` "
  "SET "
  "`active`=?, "
  "`sheduledays_week0`=?, "
  "`sheduledays_week1`=?, "
  "`sheduledays_week2`=?, "
  "`sheduledays_week3`=?, "
  "`sheduledays_week4`=?, "
  "`sheduledays_week5`=?, "
  "`sheduledays_week6`=?, "
  "`sheduledays_isset`=?, "
  "`customerid`=?, "
  "`name`=?, "
  "`description`=?, "
  "`pointstart_location_latitude`=?, "
  "`pointstart_location_longitude`=?, "
  "`pointstart_location_isset`=?, "
  "`pointstart_name`=?, "
  "`pointstart_city`=?, "
  "`pointstart_address`=?, "
  "`pointstart_isset`=?, "
  "`pointfinish_location_latitude`=?, "
  "`pointfinish_location_longitude`=?, "
  "`pointfinish_location_isset`=?, "
  "`pointfinish_name`=?, "
  "`pointfinish_city`=?, "
  "`pointfinish_address`=?, "
  "`pointfinish_isset`=?, "
  "`hasMiddlePoints`=?, "
  "`haspassenger`=?, "
  "`timestart`=?, "
  "`timefinish`=?, "
  "`sheduleoperatorid`=?, "
  "`preferreddriverid`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Shedule, id_mysql >::erase_statement[] =
  "DELETE FROM `Shedule` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Shedule, id_mysql >::query_statement[] =
  "SELECT "
  "`Shedule`.`id`, "
  "`Shedule`.`active`, "
  "`Shedule`.`sheduledays_week0`, "
  "`Shedule`.`sheduledays_week1`, "
  "`Shedule`.`sheduledays_week2`, "
  "`Shedule`.`sheduledays_week3`, "
  "`Shedule`.`sheduledays_week4`, "
  "`Shedule`.`sheduledays_week5`, "
  "`Shedule`.`sheduledays_week6`, "
  "`Shedule`.`sheduledays_isset`, "
  "`Shedule`.`customerid`, "
  "`Shedule`.`name`, "
  "`Shedule`.`description`, "
  "`Shedule`.`pointstart_location_latitude`, "
  "`Shedule`.`pointstart_location_longitude`, "
  "`Shedule`.`pointstart_location_isset`, "
  "`Shedule`.`pointstart_name`, "
  "`Shedule`.`pointstart_city`, "
  "`Shedule`.`pointstart_address`, "
  "`Shedule`.`pointstart_isset`, "
  "`Shedule`.`pointfinish_location_latitude`, "
  "`Shedule`.`pointfinish_location_longitude`, "
  "`Shedule`.`pointfinish_location_isset`, "
  "`Shedule`.`pointfinish_name`, "
  "`Shedule`.`pointfinish_city`, "
  "`Shedule`.`pointfinish_address`, "
  "`Shedule`.`pointfinish_isset`, "
  "`Shedule`.`hasMiddlePoints`, "
  "`Shedule`.`haspassenger`, "
  "`Shedule`.`timestart`, "
  "`Shedule`.`timefinish`, "
  "`Shedule`.`sheduleoperatorid`, "
  "`Shedule`.`preferreddriverid`, "
  "`Shedule`.`isset` "
  "FROM `Shedule`";

  const char access::object_traits_impl< ::taxi::Shedule, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Shedule`";

  const char access::object_traits_impl< ::taxi::Shedule, id_mysql >::table_name[] =
  "`Shedule`";

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // passengers
    //
    {
      ::taxi::Passengerids const& v =
        obj.passengers;

      passengers_traits::persist (
        v,
        esc.passengers);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // passengers
    //
    {
      ::taxi::Passengerids const& v =
        obj.passengers;

      passengers_traits::update (
        v,
        esc.passengers);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // passengers
    //
    passengers_traits::erase (
      esc.passengers);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Shedule, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // passengers
    //
    {
      ::taxi::Passengerids& v =
        obj.passengers;

      passengers_traits::load (
        v,
        esc.passengers);
    }
  }

  result< access::object_traits_impl< ::taxi::Shedule, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Shedule, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // DriverBlackList
  //

  struct access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::id_type
  access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // created
    //
    t[1UL] = 0;

    // customerid
    //
    t[2UL] = 0;

    // driverid
    //
    t[3UL] = 0;

    // __isset
    //
    if (t[4UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // created
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.created_value;
    b[n].is_null = &i.created_null;
    n++;

    // customerid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.customerid_value;
    b[n].is_null = &i.customerid_null;
    n++;

    // driverid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.driverid_value;
    b[n].is_null = &i.driverid_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // created
    //
    {
      ::taxi::DATE const& v =
        o.created;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.created_value, is_null, v);
      i.created_null = is_null;
    }

    // customerid
    //
    {
      ::taxi::ID const& v =
        o.customerid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.customerid_value, is_null, v);
      i.customerid_null = is_null;
    }

    // driverid
    //
    {
      ::taxi::ID const& v =
        o.driverid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.driverid_value, is_null, v);
      i.driverid_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_DriverBlackList__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_DriverBlackList__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // created
    //
    {
      ::taxi::DATE& v =
        o.created;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.created_value,
        i.created_null);
    }

    // customerid
    //
    {
      ::taxi::ID& v =
        o.customerid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.customerid_value,
        i.customerid_null);
    }

    // driverid
    //
    {
      ::taxi::ID& v =
        o.driverid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.driverid_value,
        i.driverid_null);
    }

    // __isset
    //
    {
      ::taxi::_DriverBlackList__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_DriverBlackList__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::persist_statement[] =
  "INSERT INTO `DriverBlackList` "
  "(`id`, "
  "`created`, "
  "`customerid`, "
  "`driverid`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::find_statement[] =
  "SELECT "
  "`DriverBlackList`.`id`, "
  "`DriverBlackList`.`created`, "
  "`DriverBlackList`.`customerid`, "
  "`DriverBlackList`.`driverid`, "
  "`DriverBlackList`.`isset` "
  "FROM `DriverBlackList` "
  "WHERE `DriverBlackList`.`id`=?";

  const char access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::update_statement[] =
  "UPDATE `DriverBlackList` "
  "SET "
  "`created`=?, "
  "`customerid`=?, "
  "`driverid`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::erase_statement[] =
  "DELETE FROM `DriverBlackList` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::query_statement[] =
  "SELECT "
  "`DriverBlackList`.`id`, "
  "`DriverBlackList`.`created`, "
  "`DriverBlackList`.`customerid`, "
  "`DriverBlackList`.`driverid`, "
  "`DriverBlackList`.`isset` "
  "FROM `DriverBlackList`";

  const char access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::erase_query_statement[] =
  "DELETE FROM `DriverBlackList`";

  const char access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::table_name[] =
  "`DriverBlackList`";

  void access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::DriverBlackList, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // SheduleStop
  //

  struct access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::id_type
  access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // sheduleid
    //
    t[1UL] = 0;

    // point
    //
    if (composite_value_traits< ::taxi::Location, id_mysql >::grow (
          i.point_value, t + 2UL))
      grew = true;

    // position
    //
    t[9UL] = 0;

    // haspassenger
    //
    t[10UL] = 0;

    // passengerid
    //
    t[11UL] = 0;

    // __isset
    //
    if (t[12UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // sheduleid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.sheduleid_value;
    b[n].is_null = &i.sheduleid_null;
    n++;

    // point
    //
    composite_value_traits< ::taxi::Location, id_mysql >::bind (
      b + n, i.point_value, sk);
    n += 7UL;

    // position
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.position_value;
    b[n].is_null = &i.position_null;
    n++;

    // haspassenger
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.haspassenger_value;
    b[n].is_null = &i.haspassenger_null;
    n++;

    // passengerid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.passengerid_value;
    b[n].is_null = &i.passengerid_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // sheduleid
    //
    {
      ::taxi::ID const& v =
        o.sheduleid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.sheduleid_value, is_null, v);
      i.sheduleid_null = is_null;
    }

    // point
    //
    {
      ::taxi::Location const& v =
        o.point;

      if (composite_value_traits< ::taxi::Location, id_mysql >::init (
            i.point_value,
            v,
            sk))
        grew = true;
    }

    // position
    //
    {
      ::taxi::NUMBER32 const& v =
        o.position;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.position_value, is_null, v);
      i.position_null = is_null;
    }

    // haspassenger
    //
    {
      bool const& v =
        o.haspassenger;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.haspassenger_value, is_null, v);
      i.haspassenger_null = is_null;
    }

    // passengerid
    //
    {
      ::taxi::ID const& v =
        o.passengerid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.passengerid_value, is_null, v);
      i.passengerid_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_SheduleStop__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_SheduleStop__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // sheduleid
    //
    {
      ::taxi::ID& v =
        o.sheduleid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.sheduleid_value,
        i.sheduleid_null);
    }

    // point
    //
    {
      ::taxi::Location& v =
        o.point;

      composite_value_traits< ::taxi::Location, id_mysql >::init (
        v,
        i.point_value,
        db);
    }

    // position
    //
    {
      ::taxi::NUMBER32& v =
        o.position;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.position_value,
        i.position_null);
    }

    // haspassenger
    //
    {
      bool& v =
        o.haspassenger;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.haspassenger_value,
        i.haspassenger_null);
    }

    // passengerid
    //
    {
      ::taxi::ID& v =
        o.passengerid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.passengerid_value,
        i.passengerid_null);
    }

    // __isset
    //
    {
      ::taxi::_SheduleStop__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_SheduleStop__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::persist_statement[] =
  "INSERT INTO `SheduleStop` "
  "(`id`, "
  "`sheduleid`, "
  "`point_location_latitude`, "
  "`point_location_longitude`, "
  "`point_location_isset`, "
  "`point_name`, "
  "`point_city`, "
  "`point_address`, "
  "`point_isset`, "
  "`position`, "
  "`haspassenger`, "
  "`passengerid`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::find_statement[] =
  "SELECT "
  "`SheduleStop`.`id`, "
  "`SheduleStop`.`sheduleid`, "
  "`SheduleStop`.`point_location_latitude`, "
  "`SheduleStop`.`point_location_longitude`, "
  "`SheduleStop`.`point_location_isset`, "
  "`SheduleStop`.`point_name`, "
  "`SheduleStop`.`point_city`, "
  "`SheduleStop`.`point_address`, "
  "`SheduleStop`.`point_isset`, "
  "`SheduleStop`.`position`, "
  "`SheduleStop`.`haspassenger`, "
  "`SheduleStop`.`passengerid`, "
  "`SheduleStop`.`isset` "
  "FROM `SheduleStop` "
  "WHERE `SheduleStop`.`id`=?";

  const char access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::update_statement[] =
  "UPDATE `SheduleStop` "
  "SET "
  "`sheduleid`=?, "
  "`point_location_latitude`=?, "
  "`point_location_longitude`=?, "
  "`point_location_isset`=?, "
  "`point_name`=?, "
  "`point_city`=?, "
  "`point_address`=?, "
  "`point_isset`=?, "
  "`position`=?, "
  "`haspassenger`=?, "
  "`passengerid`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::erase_statement[] =
  "DELETE FROM `SheduleStop` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::query_statement[] =
  "SELECT "
  "`SheduleStop`.`id`, "
  "`SheduleStop`.`sheduleid`, "
  "`SheduleStop`.`point_location_latitude`, "
  "`SheduleStop`.`point_location_longitude`, "
  "`SheduleStop`.`point_location_isset`, "
  "`SheduleStop`.`point_name`, "
  "`SheduleStop`.`point_city`, "
  "`SheduleStop`.`point_address`, "
  "`SheduleStop`.`point_isset`, "
  "`SheduleStop`.`position`, "
  "`SheduleStop`.`haspassenger`, "
  "`SheduleStop`.`passengerid`, "
  "`SheduleStop`.`isset` "
  "FROM `SheduleStop`";

  const char access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::erase_query_statement[] =
  "DELETE FROM `SheduleStop`";

  const char access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::table_name[] =
  "`SheduleStop`";

  void access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::SheduleStop, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Rate
  //

  struct access::object_traits_impl< ::taxi::Rate, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::Rate, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Rate, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Rate, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // orgserviceid
    //
    t[1UL] = 0;

    // cityid
    //
    t[2UL] = 0;

    // name
    //
    if (t[3UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // active
    //
    t[4UL] = 0;

    // datestart
    //
    t[5UL] = 0;

    // datefinish
    //
    t[6UL] = 0;

    // isweekend
    //
    t[7UL] = 0;

    // isday
    //
    t[8UL] = 0;

    // hourstart
    //
    t[9UL] = 0;

    // hourfinish
    //
    t[10UL] = 0;

    // costmin
    //
    t[11UL] = 0;

    // priceboarding
    //
    t[12UL] = 0;

    // priceminute
    //
    t[13UL] = 0;

    // pricedelay
    //
    t[14UL] = 0;

    // pricewait
    //
    t[15UL] = 0;

    // speedmin
    //
    t[16UL] = 0;

    // timedelayfree
    //
    t[17UL] = 0;

    // __isset
    //
    if (t[18UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Rate, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // orgserviceid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.orgserviceid_value;
    b[n].is_null = &i.orgserviceid_null;
    n++;

    // cityid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.cityid_value;
    b[n].is_null = &i.cityid_null;
    n++;

    // name
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.name_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.name_value.capacity ());
    b[n].length = &i.name_size;
    b[n].is_null = &i.name_null;
    n++;

    // active
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.active_value;
    b[n].is_null = &i.active_null;
    n++;

    // datestart
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.datestart_value;
    b[n].is_null = &i.datestart_null;
    n++;

    // datefinish
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.datefinish_value;
    b[n].is_null = &i.datefinish_null;
    n++;

    // isweekend
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.isweekend_value;
    b[n].is_null = &i.isweekend_null;
    n++;

    // isday
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.isday_value;
    b[n].is_null = &i.isday_null;
    n++;

    // hourstart
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.hourstart_value;
    b[n].is_null = &i.hourstart_null;
    n++;

    // hourfinish
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.hourfinish_value;
    b[n].is_null = &i.hourfinish_null;
    n++;

    // costmin
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.costmin_value;
    b[n].is_null = &i.costmin_null;
    n++;

    // priceboarding
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.priceboarding_value;
    b[n].is_null = &i.priceboarding_null;
    n++;

    // priceminute
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.priceminute_value;
    b[n].is_null = &i.priceminute_null;
    n++;

    // pricedelay
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.pricedelay_value;
    b[n].is_null = &i.pricedelay_null;
    n++;

    // pricewait
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.pricewait_value;
    b[n].is_null = &i.pricewait_null;
    n++;

    // speedmin
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.speedmin_value;
    b[n].is_null = &i.speedmin_null;
    n++;

    // timedelayfree
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.timedelayfree_value;
    b[n].is_null = &i.timedelayfree_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Rate, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Rate, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // orgserviceid
    //
    {
      ::taxi::OrgServiceid const& v =
        o.orgserviceid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::OrgServiceid,
          mysql::id_longlong >::set_image (
        i.orgserviceid_value, is_null, v);
      i.orgserviceid_null = is_null;
    }

    // cityid
    //
    {
      ::taxi::ID const& v =
        o.cityid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.cityid_value, is_null, v);
      i.cityid_null = is_null;
    }

    // name
    //
    {
      ::taxi::STR const& v =
        o.name;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.name_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.name_value,
        size,
        is_null,
        v);
      i.name_null = is_null;
      i.name_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.name_value.capacity ());
    }

    // active
    //
    {
      bool const& v =
        o.active;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.active_value, is_null, v);
      i.active_null = is_null;
    }

    // datestart
    //
    {
      ::taxi::DATE const& v =
        o.datestart;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.datestart_value, is_null, v);
      i.datestart_null = is_null;
    }

    // datefinish
    //
    {
      ::taxi::DATE const& v =
        o.datefinish;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.datefinish_value, is_null, v);
      i.datefinish_null = is_null;
    }

    // isweekend
    //
    {
      bool const& v =
        o.isweekend;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.isweekend_value, is_null, v);
      i.isweekend_null = is_null;
    }

    // isday
    //
    {
      bool const& v =
        o.isday;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.isday_value, is_null, v);
      i.isday_null = is_null;
    }

    // hourstart
    //
    {
      ::taxi::NUMBER32 const& v =
        o.hourstart;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.hourstart_value, is_null, v);
      i.hourstart_null = is_null;
    }

    // hourfinish
    //
    {
      ::taxi::NUMBER32 const& v =
        o.hourfinish;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.hourfinish_value, is_null, v);
      i.hourfinish_null = is_null;
    }

    // costmin
    //
    {
      ::taxi::CURR const& v =
        o.costmin;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.costmin_value, is_null, v);
      i.costmin_null = is_null;
    }

    // priceboarding
    //
    {
      ::taxi::CURR const& v =
        o.priceboarding;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.priceboarding_value, is_null, v);
      i.priceboarding_null = is_null;
    }

    // priceminute
    //
    {
      ::taxi::CURR const& v =
        o.priceminute;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.priceminute_value, is_null, v);
      i.priceminute_null = is_null;
    }

    // pricedelay
    //
    {
      ::taxi::CURR const& v =
        o.pricedelay;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.pricedelay_value, is_null, v);
      i.pricedelay_null = is_null;
    }

    // pricewait
    //
    {
      ::taxi::CURR const& v =
        o.pricewait;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.pricewait_value, is_null, v);
      i.pricewait_null = is_null;
    }

    // speedmin
    //
    {
      ::taxi::NUMBER32 const& v =
        o.speedmin;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.speedmin_value, is_null, v);
      i.speedmin_null = is_null;
    }

    // timedelayfree
    //
    {
      ::taxi::NUMBER32 const& v =
        o.timedelayfree;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.timedelayfree_value, is_null, v);
      i.timedelayfree_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_Rate__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Rate__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Rate, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // orgserviceid
    //
    {
      ::taxi::OrgServiceid& v =
        o.orgserviceid;

      mysql::value_traits<
          ::taxi::OrgServiceid,
          mysql::id_longlong >::set_value (
        v,
        i.orgserviceid_value,
        i.orgserviceid_null);
    }

    // cityid
    //
    {
      ::taxi::ID& v =
        o.cityid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.cityid_value,
        i.cityid_null);
    }

    // name
    //
    {
      ::taxi::STR& v =
        o.name;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // active
    //
    {
      bool& v =
        o.active;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.active_value,
        i.active_null);
    }

    // datestart
    //
    {
      ::taxi::DATE& v =
        o.datestart;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.datestart_value,
        i.datestart_null);
    }

    // datefinish
    //
    {
      ::taxi::DATE& v =
        o.datefinish;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.datefinish_value,
        i.datefinish_null);
    }

    // isweekend
    //
    {
      bool& v =
        o.isweekend;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.isweekend_value,
        i.isweekend_null);
    }

    // isday
    //
    {
      bool& v =
        o.isday;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.isday_value,
        i.isday_null);
    }

    // hourstart
    //
    {
      ::taxi::NUMBER32& v =
        o.hourstart;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.hourstart_value,
        i.hourstart_null);
    }

    // hourfinish
    //
    {
      ::taxi::NUMBER32& v =
        o.hourfinish;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.hourfinish_value,
        i.hourfinish_null);
    }

    // costmin
    //
    {
      ::taxi::CURR& v =
        o.costmin;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.costmin_value,
        i.costmin_null);
    }

    // priceboarding
    //
    {
      ::taxi::CURR& v =
        o.priceboarding;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.priceboarding_value,
        i.priceboarding_null);
    }

    // priceminute
    //
    {
      ::taxi::CURR& v =
        o.priceminute;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.priceminute_value,
        i.priceminute_null);
    }

    // pricedelay
    //
    {
      ::taxi::CURR& v =
        o.pricedelay;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.pricedelay_value,
        i.pricedelay_null);
    }

    // pricewait
    //
    {
      ::taxi::CURR& v =
        o.pricewait;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.pricewait_value,
        i.pricewait_null);
    }

    // speedmin
    //
    {
      ::taxi::NUMBER32& v =
        o.speedmin;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.speedmin_value,
        i.speedmin_null);
    }

    // timedelayfree
    //
    {
      ::taxi::NUMBER32& v =
        o.timedelayfree;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.timedelayfree_value,
        i.timedelayfree_null);
    }

    // __isset
    //
    {
      ::taxi::_Rate__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Rate__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Rate, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Rate, id_mysql >::persist_statement[] =
  "INSERT INTO `Rate` "
  "(`id`, "
  "`orgserviceid`, "
  "`cityid`, "
  "`name`, "
  "`active`, "
  "`datestart`, "
  "`datefinish`, "
  "`isweekend`, "
  "`isday`, "
  "`hourstart`, "
  "`hourfinish`, "
  "`costmin`, "
  "`priceboarding`, "
  "`priceminute`, "
  "`pricedelay`, "
  "`pricewait`, "
  "`speedmin`, "
  "`timedelayfree`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Rate, id_mysql >::find_statement[] =
  "SELECT "
  "`Rate`.`id`, "
  "`Rate`.`orgserviceid`, "
  "`Rate`.`cityid`, "
  "`Rate`.`name`, "
  "`Rate`.`active`, "
  "`Rate`.`datestart`, "
  "`Rate`.`datefinish`, "
  "`Rate`.`isweekend`, "
  "`Rate`.`isday`, "
  "`Rate`.`hourstart`, "
  "`Rate`.`hourfinish`, "
  "`Rate`.`costmin`, "
  "`Rate`.`priceboarding`, "
  "`Rate`.`priceminute`, "
  "`Rate`.`pricedelay`, "
  "`Rate`.`pricewait`, "
  "`Rate`.`speedmin`, "
  "`Rate`.`timedelayfree`, "
  "`Rate`.`isset` "
  "FROM `Rate` "
  "WHERE `Rate`.`id`=?";

  const char access::object_traits_impl< ::taxi::Rate, id_mysql >::update_statement[] =
  "UPDATE `Rate` "
  "SET "
  "`orgserviceid`=?, "
  "`cityid`=?, "
  "`name`=?, "
  "`active`=?, "
  "`datestart`=?, "
  "`datefinish`=?, "
  "`isweekend`=?, "
  "`isday`=?, "
  "`hourstart`=?, "
  "`hourfinish`=?, "
  "`costmin`=?, "
  "`priceboarding`=?, "
  "`priceminute`=?, "
  "`pricedelay`=?, "
  "`pricewait`=?, "
  "`speedmin`=?, "
  "`timedelayfree`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Rate, id_mysql >::erase_statement[] =
  "DELETE FROM `Rate` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Rate, id_mysql >::query_statement[] =
  "SELECT "
  "`Rate`.`id`, "
  "`Rate`.`orgserviceid`, "
  "`Rate`.`cityid`, "
  "`Rate`.`name`, "
  "`Rate`.`active`, "
  "`Rate`.`datestart`, "
  "`Rate`.`datefinish`, "
  "`Rate`.`isweekend`, "
  "`Rate`.`isday`, "
  "`Rate`.`hourstart`, "
  "`Rate`.`hourfinish`, "
  "`Rate`.`costmin`, "
  "`Rate`.`priceboarding`, "
  "`Rate`.`priceminute`, "
  "`Rate`.`pricedelay`, "
  "`Rate`.`pricewait`, "
  "`Rate`.`speedmin`, "
  "`Rate`.`timedelayfree`, "
  "`Rate`.`isset` "
  "FROM `Rate`";

  const char access::object_traits_impl< ::taxi::Rate, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Rate`";

  const char access::object_traits_impl< ::taxi::Rate, id_mysql >::table_name[] =
  "`Rate`";

  void access::object_traits_impl< ::taxi::Rate, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Rate, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Rate, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Rate, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Rate, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Rate, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Rate, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Rate, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::Rate, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Rate, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Rate, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Notification
  //

  struct access::object_traits_impl< ::taxi::Notification, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::Notification, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Notification, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Notification, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // isactive
    //
    t[1UL] = 0;

    // msgtime
    //
    t[2UL] = 0;

    // msgfrom
    //
    if (t[3UL])
    {
      if (mysql::enum_traits::grow (i.msgfrom_value, i.msgfrom_size))
        grew = true;
      else
        t[3UL] = 0;
    }

    // driverid
    //
    t[4UL] = 0;

    // todriver
    //
    t[5UL] = 0;

    // tooperator
    //
    t[6UL] = 0;

    // topassenger
    //
    t[7UL] = 0;

    // todispatcher
    //
    t[8UL] = 0;

    // note
    //
    if (t[9UL])
    {
      i.note_value.capacity (i.note_size);
      grew = true;
    }

    // __isset
    //
    if (t[10UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Notification, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // isactive
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.isactive_value;
    b[n].is_null = &i.isactive_null;
    n++;

    // msgtime
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.msgtime_value;
    b[n].is_null = &i.msgtime_null;
    n++;

    // msgfrom
    //
    mysql::enum_traits::bind (b[n],
                              i.msgfrom_value,
                              i.msgfrom_size,
                              &i.msgfrom_null);
    n++;

    // driverid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.driverid_value;
    b[n].is_null = &i.driverid_null;
    n++;

    // todriver
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.todriver_value;
    b[n].is_null = &i.todriver_null;
    n++;

    // tooperator
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.tooperator_value;
    b[n].is_null = &i.tooperator_null;
    n++;

    // topassenger
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.topassenger_value;
    b[n].is_null = &i.topassenger_null;
    n++;

    // todispatcher
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.todispatcher_value;
    b[n].is_null = &i.todispatcher_null;
    n++;

    // note
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.note_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.note_value.capacity ());
    b[n].length = &i.note_size;
    b[n].is_null = &i.note_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Notification, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Notification, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // isactive
    //
    {
      bool const& v =
        o.isactive;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.isactive_value, is_null, v);
      i.isactive_null = is_null;
    }

    // msgtime
    //
    {
      ::taxi::DATE const& v =
        o.msgtime;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.msgtime_value, is_null, v);
      i.msgtime_null = is_null;
    }

    // msgfrom
    //
    {
      ::taxi::PersonRole::type const& v =
        o.msgfrom;

      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.msgfrom_value,
            i.msgfrom_size,
            is_null,
            v))
        grew = true;

      i.msgfrom_null = is_null;
    }

    // driverid
    //
    {
      ::taxi::ID const& v =
        o.driverid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.driverid_value, is_null, v);
      i.driverid_null = is_null;
    }

    // todriver
    //
    {
      bool const& v =
        o.todriver;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.todriver_value, is_null, v);
      i.todriver_null = is_null;
    }

    // tooperator
    //
    {
      bool const& v =
        o.tooperator;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.tooperator_value, is_null, v);
      i.tooperator_null = is_null;
    }

    // topassenger
    //
    {
      bool const& v =
        o.topassenger;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.topassenger_value, is_null, v);
      i.topassenger_null = is_null;
    }

    // todispatcher
    //
    {
      bool const& v =
        o.todispatcher;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.todispatcher_value, is_null, v);
      i.todispatcher_null = is_null;
    }

    // note
    //
    {
      ::taxi::STR const& v =
        o.note;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.note_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.note_value,
        size,
        is_null,
        v);
      i.note_null = is_null;
      i.note_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.note_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_Notification__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Notification__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Notification, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // isactive
    //
    {
      bool& v =
        o.isactive;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.isactive_value,
        i.isactive_null);
    }

    // msgtime
    //
    {
      ::taxi::DATE& v =
        o.msgtime;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.msgtime_value,
        i.msgtime_null);
    }

    // msgfrom
    //
    {
      ::taxi::PersonRole::type& v =
        o.msgfrom;

      mysql::enum_traits::set_value (
        v,
        i.msgfrom_value,
        i.msgfrom_size,
        i.msgfrom_null);
    }

    // driverid
    //
    {
      ::taxi::ID& v =
        o.driverid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.driverid_value,
        i.driverid_null);
    }

    // todriver
    //
    {
      bool& v =
        o.todriver;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.todriver_value,
        i.todriver_null);
    }

    // tooperator
    //
    {
      bool& v =
        o.tooperator;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.tooperator_value,
        i.tooperator_null);
    }

    // topassenger
    //
    {
      bool& v =
        o.topassenger;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.topassenger_value,
        i.topassenger_null);
    }

    // todispatcher
    //
    {
      bool& v =
        o.todispatcher;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.todispatcher_value,
        i.todispatcher_null);
    }

    // note
    //
    {
      ::taxi::STR& v =
        o.note;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.note_value,
        i.note_size,
        i.note_null);
    }

    // __isset
    //
    {
      ::taxi::_Notification__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Notification__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Notification, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Notification, id_mysql >::persist_statement[] =
  "INSERT INTO `Notification` "
  "(`id`, "
  "`isactive`, "
  "`msgtime`, "
  "`msgfrom`, "
  "`driverid`, "
  "`todriver`, "
  "`tooperator`, "
  "`topassenger`, "
  "`todispatcher`, "
  "`note`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Notification, id_mysql >::find_statement[] =
  "SELECT "
  "`Notification`.`id`, "
  "`Notification`.`isactive`, "
  "`Notification`.`msgtime`, "
  "CONCAT(`Notification`.`msgfrom`+0,' ',`Notification`.`msgfrom`), "
  "`Notification`.`driverid`, "
  "`Notification`.`todriver`, "
  "`Notification`.`tooperator`, "
  "`Notification`.`topassenger`, "
  "`Notification`.`todispatcher`, "
  "`Notification`.`note`, "
  "`Notification`.`isset` "
  "FROM `Notification` "
  "WHERE `Notification`.`id`=?";

  const char access::object_traits_impl< ::taxi::Notification, id_mysql >::update_statement[] =
  "UPDATE `Notification` "
  "SET "
  "`isactive`=?, "
  "`msgtime`=?, "
  "`msgfrom`=?, "
  "`driverid`=?, "
  "`todriver`=?, "
  "`tooperator`=?, "
  "`topassenger`=?, "
  "`todispatcher`=?, "
  "`note`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Notification, id_mysql >::erase_statement[] =
  "DELETE FROM `Notification` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Notification, id_mysql >::query_statement[] =
  "SELECT "
  "`Notification`.`id`, "
  "`Notification`.`isactive`, "
  "`Notification`.`msgtime`, "
  "CONCAT(`Notification`.`msgfrom`+0,' ',`Notification`.`msgfrom`), "
  "`Notification`.`driverid`, "
  "`Notification`.`todriver`, "
  "`Notification`.`tooperator`, "
  "`Notification`.`topassenger`, "
  "`Notification`.`todispatcher`, "
  "`Notification`.`note`, "
  "`Notification`.`isset` "
  "FROM `Notification`";

  const char access::object_traits_impl< ::taxi::Notification, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Notification`";

  const char access::object_traits_impl< ::taxi::Notification, id_mysql >::table_name[] =
  "`Notification`";

  void access::object_traits_impl< ::taxi::Notification, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Notification, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Notification, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Notification, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Notification, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Notification, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Notification, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Notification, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::Notification, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Notification, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Notification, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // BillAct
  //

  struct access::object_traits_impl< ::taxi::BillAct, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< orgservice_traits > orgservice;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : orgservice (c, id)
    {
    }
  };

  // orgservice
  //

  const char access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  select_statement[] =
  "SELECT "
  "CONCAT(`BillAct_orgservice`.`key`+0,' ',`BillAct_orgservice`.`key`), "
  "`BillAct_orgservice`.`value` "
  "FROM `BillAct_orgservice` "
  "WHERE `BillAct_orgservice`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  insert_statement[] =
  "INSERT INTO `BillAct_orgservice` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  delete_statement[] =
  "DELETE FROM `BillAct_orgservice` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    mysql::enum_traits::bind (b[n],
                              d.key_value,
                              d.key_size,
                              &d.key_null);
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    if (t[0UL])
    {
      if (mysql::enum_traits::grow (i.key_value, i.key_size))
        grew = true;
      else
        t[0UL] = 0;
    }

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      if (mysql::enum_traits::set_image (
            i.key_value,
            i.key_size,
            is_null,
            *k))
        grew = true;

      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::enum_traits::set_value (
        k,
        i.key_value,
        i.key_size,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::orgservice_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::BillAct, id_mysql >::id_type
  access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // customerid
    //
    t[1UL] = 0;

    // periodid
    //
    t[2UL] = 0;

    // datestart
    //
    t[3UL] = 0;

    // datefinish
    //
    t[4UL] = 0;

    // total0
    //
    t[5UL] = 0;

    // total1
    //
    t[6UL] = 0;

    // total2
    //
    t[7UL] = 0;

    // taxpercent
    //
    t[8UL] = 0;

    // tax
    //
    t[9UL] = 0;

    // hasdiscount
    //
    t[10UL] = 0;

    // created
    //
    t[11UL] = 0;

    // haspayments
    //
    t[12UL] = 0;

    // paid
    //
    t[13UL] = 0;

    // datepaid
    //
    t[14UL] = 0;

    // sumbefore
    //
    t[15UL] = 0;

    // sumafter
    //
    t[16UL] = 0;

    // note
    //
    if (t[17UL])
    {
      i.note_value.capacity (i.note_size);
      grew = true;
    }

    // billno
    //
    if (t[18UL])
    {
      i.billno_value.capacity (i.billno_size);
      grew = true;
    }

    // actno
    //
    if (t[19UL])
    {
      i.actno_value.capacity (i.actno_size);
      grew = true;
    }

    // __isset
    //
    if (t[20UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // customerid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.customerid_value;
    b[n].is_null = &i.customerid_null;
    n++;

    // periodid
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.periodid_value;
    b[n].is_null = &i.periodid_null;
    n++;

    // datestart
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.datestart_value;
    b[n].is_null = &i.datestart_null;
    n++;

    // datefinish
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.datefinish_value;
    b[n].is_null = &i.datefinish_null;
    n++;

    // total0
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.total0_value;
    b[n].is_null = &i.total0_null;
    n++;

    // total1
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.total1_value;
    b[n].is_null = &i.total1_null;
    n++;

    // total2
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.total2_value;
    b[n].is_null = &i.total2_null;
    n++;

    // taxpercent
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.taxpercent_value;
    b[n].is_null = &i.taxpercent_null;
    n++;

    // tax
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.tax_value;
    b[n].is_null = &i.tax_null;
    n++;

    // hasdiscount
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.hasdiscount_value;
    b[n].is_null = &i.hasdiscount_null;
    n++;

    // created
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.created_value;
    b[n].is_null = &i.created_null;
    n++;

    // haspayments
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.haspayments_value;
    b[n].is_null = &i.haspayments_null;
    n++;

    // paid
    //
    b[n].buffer_type = MYSQL_TYPE_TINY;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.paid_value;
    b[n].is_null = &i.paid_null;
    n++;

    // datepaid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.datepaid_value;
    b[n].is_null = &i.datepaid_null;
    n++;

    // sumbefore
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.sumbefore_value;
    b[n].is_null = &i.sumbefore_null;
    n++;

    // sumafter
    //
    b[n].buffer_type = MYSQL_TYPE_DOUBLE;
    b[n].buffer = &i.sumafter_value;
    b[n].is_null = &i.sumafter_null;
    n++;

    // note
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.note_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.note_value.capacity ());
    b[n].length = &i.note_size;
    b[n].is_null = &i.note_null;
    n++;

    // billno
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.billno_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.billno_value.capacity ());
    b[n].length = &i.billno_size;
    b[n].is_null = &i.billno_null;
    n++;

    // actno
    //
    b[n].buffer_type = MYSQL_TYPE_STRING;
    b[n].buffer = i.actno_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.actno_value.capacity ());
    b[n].length = &i.actno_size;
    b[n].is_null = &i.actno_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // customerid
    //
    {
      ::taxi::ID const& v =
        o.customerid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.customerid_value, is_null, v);
      i.customerid_null = is_null;
    }

    // periodid
    //
    {
      ::taxi::NUMBER32 const& v =
        o.periodid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.periodid_value, is_null, v);
      i.periodid_null = is_null;
    }

    // datestart
    //
    {
      ::taxi::DATE const& v =
        o.datestart;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.datestart_value, is_null, v);
      i.datestart_null = is_null;
    }

    // datefinish
    //
    {
      ::taxi::DATE const& v =
        o.datefinish;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.datefinish_value, is_null, v);
      i.datefinish_null = is_null;
    }

    // total0
    //
    {
      ::taxi::CURR const& v =
        o.total0;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.total0_value, is_null, v);
      i.total0_null = is_null;
    }

    // total1
    //
    {
      ::taxi::CURR const& v =
        o.total1;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.total1_value, is_null, v);
      i.total1_null = is_null;
    }

    // total2
    //
    {
      ::taxi::CURR const& v =
        o.total2;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.total2_value, is_null, v);
      i.total2_null = is_null;
    }

    // taxpercent
    //
    {
      ::taxi::CURR const& v =
        o.taxpercent;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.taxpercent_value, is_null, v);
      i.taxpercent_null = is_null;
    }

    // tax
    //
    {
      ::taxi::CURR const& v =
        o.tax;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.tax_value, is_null, v);
      i.tax_null = is_null;
    }

    // hasdiscount
    //
    {
      bool const& v =
        o.hasdiscount;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.hasdiscount_value, is_null, v);
      i.hasdiscount_null = is_null;
    }

    // created
    //
    {
      ::taxi::DATE const& v =
        o.created;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.created_value, is_null, v);
      i.created_null = is_null;
    }

    // haspayments
    //
    {
      bool const& v =
        o.haspayments;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.haspayments_value, is_null, v);
      i.haspayments_null = is_null;
    }

    // paid
    //
    {
      bool const& v =
        o.paid;

      bool is_null (false);
      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_image (
        i.paid_value, is_null, v);
      i.paid_null = is_null;
    }

    // datepaid
    //
    {
      ::taxi::DATE const& v =
        o.datepaid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.datepaid_value, is_null, v);
      i.datepaid_null = is_null;
    }

    // sumbefore
    //
    {
      ::taxi::CURR const& v =
        o.sumbefore;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.sumbefore_value, is_null, v);
      i.sumbefore_null = is_null;
    }

    // sumafter
    //
    {
      ::taxi::CURR const& v =
        o.sumafter;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_image (
        i.sumafter_value, is_null, v);
      i.sumafter_null = is_null;
    }

    // note
    //
    {
      ::taxi::STR const& v =
        o.note;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.note_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.note_value,
        size,
        is_null,
        v);
      i.note_null = is_null;
      i.note_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.note_value.capacity ());
    }

    // billno
    //
    {
      ::taxi::STR const& v =
        o.billno;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.billno_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.billno_value,
        size,
        is_null,
        v);
      i.billno_null = is_null;
      i.billno_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.billno_value.capacity ());
    }

    // actno
    //
    {
      ::taxi::STR const& v =
        o.actno;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.actno_value.capacity ());
      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_image (
        i.actno_value,
        size,
        is_null,
        v);
      i.actno_null = is_null;
      i.actno_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.actno_value.capacity ());
    }

    // __isset
    //
    {
      ::taxi::_BillAct__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_BillAct__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // customerid
    //
    {
      ::taxi::ID& v =
        o.customerid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.customerid_value,
        i.customerid_null);
    }

    // periodid
    //
    {
      ::taxi::NUMBER32& v =
        o.periodid;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.periodid_value,
        i.periodid_null);
    }

    // datestart
    //
    {
      ::taxi::DATE& v =
        o.datestart;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.datestart_value,
        i.datestart_null);
    }

    // datefinish
    //
    {
      ::taxi::DATE& v =
        o.datefinish;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.datefinish_value,
        i.datefinish_null);
    }

    // total0
    //
    {
      ::taxi::CURR& v =
        o.total0;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.total0_value,
        i.total0_null);
    }

    // total1
    //
    {
      ::taxi::CURR& v =
        o.total1;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.total1_value,
        i.total1_null);
    }

    // total2
    //
    {
      ::taxi::CURR& v =
        o.total2;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.total2_value,
        i.total2_null);
    }

    // taxpercent
    //
    {
      ::taxi::CURR& v =
        o.taxpercent;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.taxpercent_value,
        i.taxpercent_null);
    }

    // tax
    //
    {
      ::taxi::CURR& v =
        o.tax;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.tax_value,
        i.tax_null);
    }

    // hasdiscount
    //
    {
      bool& v =
        o.hasdiscount;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.hasdiscount_value,
        i.hasdiscount_null);
    }

    // created
    //
    {
      ::taxi::DATE& v =
        o.created;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.created_value,
        i.created_null);
    }

    // haspayments
    //
    {
      bool& v =
        o.haspayments;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.haspayments_value,
        i.haspayments_null);
    }

    // paid
    //
    {
      bool& v =
        o.paid;

      mysql::value_traits<
          bool,
          mysql::id_tiny >::set_value (
        v,
        i.paid_value,
        i.paid_null);
    }

    // datepaid
    //
    {
      ::taxi::DATE& v =
        o.datepaid;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.datepaid_value,
        i.datepaid_null);
    }

    // sumbefore
    //
    {
      ::taxi::CURR& v =
        o.sumbefore;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.sumbefore_value,
        i.sumbefore_null);
    }

    // sumafter
    //
    {
      ::taxi::CURR& v =
        o.sumafter;

      mysql::value_traits<
          ::taxi::CURR,
          mysql::id_double >::set_value (
        v,
        i.sumafter_value,
        i.sumafter_null);
    }

    // note
    //
    {
      ::taxi::STR& v =
        o.note;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.note_value,
        i.note_size,
        i.note_null);
    }

    // billno
    //
    {
      ::taxi::STR& v =
        o.billno;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.billno_value,
        i.billno_size,
        i.billno_null);
    }

    // actno
    //
    {
      ::taxi::STR& v =
        o.actno;

      mysql::value_traits<
          ::taxi::STR,
          mysql::id_string >::set_value (
        v,
        i.actno_value,
        i.actno_size,
        i.actno_null);
    }

    // __isset
    //
    {
      ::taxi::_BillAct__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_BillAct__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::BillAct, id_mysql >::persist_statement[] =
  "INSERT INTO `BillAct` "
  "(`id`, "
  "`customerid`, "
  "`periodid`, "
  "`datestart`, "
  "`datefinish`, "
  "`total0`, "
  "`total1`, "
  "`total2`, "
  "`taxpercent`, "
  "`tax`, "
  "`hasdiscount`, "
  "`created`, "
  "`haspayments`, "
  "`paid`, "
  "`datepaid`, "
  "`sumbefore`, "
  "`sumafter`, "
  "`note`, "
  "`billno`, "
  "`actno`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::BillAct, id_mysql >::find_statement[] =
  "SELECT "
  "`BillAct`.`id`, "
  "`BillAct`.`customerid`, "
  "`BillAct`.`periodid`, "
  "`BillAct`.`datestart`, "
  "`BillAct`.`datefinish`, "
  "`BillAct`.`total0`, "
  "`BillAct`.`total1`, "
  "`BillAct`.`total2`, "
  "`BillAct`.`taxpercent`, "
  "`BillAct`.`tax`, "
  "`BillAct`.`hasdiscount`, "
  "`BillAct`.`created`, "
  "`BillAct`.`haspayments`, "
  "`BillAct`.`paid`, "
  "`BillAct`.`datepaid`, "
  "`BillAct`.`sumbefore`, "
  "`BillAct`.`sumafter`, "
  "`BillAct`.`note`, "
  "`BillAct`.`billno`, "
  "`BillAct`.`actno`, "
  "`BillAct`.`isset` "
  "FROM `BillAct` "
  "WHERE `BillAct`.`id`=?";

  const char access::object_traits_impl< ::taxi::BillAct, id_mysql >::update_statement[] =
  "UPDATE `BillAct` "
  "SET "
  "`customerid`=?, "
  "`periodid`=?, "
  "`datestart`=?, "
  "`datefinish`=?, "
  "`total0`=?, "
  "`total1`=?, "
  "`total2`=?, "
  "`taxpercent`=?, "
  "`tax`=?, "
  "`hasdiscount`=?, "
  "`created`=?, "
  "`haspayments`=?, "
  "`paid`=?, "
  "`datepaid`=?, "
  "`sumbefore`=?, "
  "`sumafter`=?, "
  "`note`=?, "
  "`billno`=?, "
  "`actno`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::BillAct, id_mysql >::erase_statement[] =
  "DELETE FROM `BillAct` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::BillAct, id_mysql >::query_statement[] =
  "SELECT "
  "`BillAct`.`id`, "
  "`BillAct`.`customerid`, "
  "`BillAct`.`periodid`, "
  "`BillAct`.`datestart`, "
  "`BillAct`.`datefinish`, "
  "`BillAct`.`total0`, "
  "`BillAct`.`total1`, "
  "`BillAct`.`total2`, "
  "`BillAct`.`taxpercent`, "
  "`BillAct`.`tax`, "
  "`BillAct`.`hasdiscount`, "
  "`BillAct`.`created`, "
  "`BillAct`.`haspayments`, "
  "`BillAct`.`paid`, "
  "`BillAct`.`datepaid`, "
  "`BillAct`.`sumbefore`, "
  "`BillAct`.`sumafter`, "
  "`BillAct`.`note`, "
  "`BillAct`.`billno`, "
  "`BillAct`.`actno`, "
  "`BillAct`.`isset` "
  "FROM `BillAct`";

  const char access::object_traits_impl< ::taxi::BillAct, id_mysql >::erase_query_statement[] =
  "DELETE FROM `BillAct`";

  const char access::object_traits_impl< ::taxi::BillAct, id_mysql >::table_name[] =
  "`BillAct`";

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orgservice
    //
    {
      ::taxi::RoleOrgService const& v =
        obj.orgservice;

      orgservice_traits::persist (
        v,
        esc.orgservice);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orgservice
    //
    {
      ::taxi::RoleOrgService const& v =
        obj.orgservice;

      orgservice_traits::update (
        v,
        esc.orgservice);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orgservice
    //
    orgservice_traits::erase (
      esc.orgservice);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::BillAct, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // orgservice
    //
    {
      ::taxi::RoleOrgService& v =
        obj.orgservice;

      orgservice_traits::load (
        v,
        esc.orgservice);
    }
  }

  result< access::object_traits_impl< ::taxi::BillAct, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::BillAct, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Payment
  //

  struct access::object_traits_impl< ::taxi::Payment, id_mysql >::extra_statement_cache_type
  {
    mysql::container_statements_impl< document_traits > document;

    extra_statement_cache_type (
      mysql::connection& c,
      image_type&,
      mysql::binding& id,
      mysql::binding&)
    : document (c, id)
    {
    }
  };

  // document
  //

  const char access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  select_statement[] =
  "SELECT "
  "`Payment_document`.`key`, "
  "`Payment_document`.`value` "
  "FROM `Payment_document` "
  "WHERE `Payment_document`.`object_id`=?";

  const char access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  insert_statement[] =
  "INSERT INTO `Payment_document` "
  "(`object_id`, "
  "`key`, "
  "`value`) "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  delete_statement[] =
  "DELETE FROM `Payment_document` "
  "WHERE `object_id`=?";

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  bind (MYSQL_BIND* b,
        const MYSQL_BIND* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace mysql;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 1;
    b[n].buffer = &d.key_value;
    b[n].is_null = &d.key_null;
    n++;

    // value
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  grow (data_image_type& i,
        my_bool* t)
  {
    bool grew (false);

    // key
    //
    t[0UL] = 0;

    // value
    //
    t[1UL] = 0;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace mysql;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      mysql::value_traits<
          key_type,
          mysql::id_ulong >::set_image (
        i.key_value, is_null, *k);
      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_image (
        i.value_value, is_null, v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      mysql::value_traits<
          key_type,
          mysql::id_ulong >::set_value (
        k,
        i.key_value,
        i.key_null);
    }

    // value
    //
    {
      mysql::value_traits<
          value_type,
          mysql::id_longlong >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace mysql;
    using mysql::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  delete_ (void* d)
  {
    using namespace mysql;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace mysql;
    using mysql::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::document_traits::
  erase (statements_type& sts)
  {
    using namespace mysql;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::taxi::Payment, id_mysql >::id_type
  access::object_traits_impl< ::taxi::Payment, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::Payment, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // billactid
    //
    t[1UL] = 0;

    // datereceived
    //
    t[2UL] = 0;

    // __isset
    //
    if (t[3UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // billactid
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.billactid_value;
    b[n].is_null = &i.billactid_null;
    n++;

    // datereceived
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.datereceived_value;
    b[n].is_null = &i.datereceived_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::Payment, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // billactid
    //
    {
      ::taxi::ID const& v =
        o.billactid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.billactid_value, is_null, v);
      i.billactid_null = is_null;
    }

    // datereceived
    //
    {
      ::taxi::DATE const& v =
        o.datereceived;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.datereceived_value, is_null, v);
      i.datereceived_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_Payment__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_Payment__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // billactid
    //
    {
      ::taxi::ID& v =
        o.billactid;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.billactid_value,
        i.billactid_null);
    }

    // datereceived
    //
    {
      ::taxi::DATE& v =
        o.datereceived;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.datereceived_value,
        i.datereceived_null);
    }

    // __isset
    //
    {
      ::taxi::_Payment__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_Payment__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::Payment, id_mysql >::persist_statement[] =
  "INSERT INTO `Payment` "
  "(`id`, "
  "`billactid`, "
  "`datereceived`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::Payment, id_mysql >::find_statement[] =
  "SELECT "
  "`Payment`.`id`, "
  "`Payment`.`billactid`, "
  "`Payment`.`datereceived`, "
  "`Payment`.`isset` "
  "FROM `Payment` "
  "WHERE `Payment`.`id`=?";

  const char access::object_traits_impl< ::taxi::Payment, id_mysql >::update_statement[] =
  "UPDATE `Payment` "
  "SET "
  "`billactid`=?, "
  "`datereceived`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Payment, id_mysql >::erase_statement[] =
  "DELETE FROM `Payment` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::Payment, id_mysql >::query_statement[] =
  "SELECT "
  "`Payment`.`id`, "
  "`Payment`.`billactid`, "
  "`Payment`.`datereceived`, "
  "`Payment`.`isset` "
  "FROM `Payment`";

  const char access::object_traits_impl< ::taxi::Payment, id_mysql >::erase_query_statement[] =
  "DELETE FROM `Payment`";

  const char access::object_traits_impl< ::taxi::Payment, id_mysql >::table_name[] =
  "`Payment`";

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // document
    //
    {
      ::taxi::DocumentMap const& v =
        obj.document;

      document_traits::persist (
        v,
        esc.document);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // document
    //
    {
      ::taxi::DocumentMap const& v =
        obj.document;

      document_traits::update (
        v,
        esc.document);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // document
    //
    document_traits::erase (
      esc.document);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::Payment, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::Payment, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::Payment, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::Payment, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::Payment, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::taxi::Payment, id_mysql >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // document
    //
    {
      ::taxi::DocumentMap& v =
        obj.document;

      document_traits::load (
        v,
        esc.document);
    }
  }

  result< access::object_traits_impl< ::taxi::Payment, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::Payment, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::Payment, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // AutoPayment
  //

  struct access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      mysql::connection&,
      image_type&,
      mysql::binding&,
      mysql::binding&)
    {
    }
  };

  access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::id_type
  access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  id (const image_type& i)
  {
    mysql::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  grow (image_type& i,
        my_bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = 0;

    // periodid
    //
    t[1UL] = 0;

    // datestart
    //
    t[2UL] = 0;

    // datefinish
    //
    t[3UL] = 0;

    // state
    //
    t[4UL] = 0;

    // __isset
    //
    if (t[5UL])
    {
      i.__isset_value.capacity (i.__isset_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  bind (MYSQL_BIND* b,
        image_type& i,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    std::size_t n (0);

    // id
    //
    if (sk != statement_update)
    {
      b[n].buffer_type = MYSQL_TYPE_LONGLONG;
      b[n].is_unsigned = 0;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // periodid
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.periodid_value;
    b[n].is_null = &i.periodid_null;
    n++;

    // datestart
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.datestart_value;
    b[n].is_null = &i.datestart_null;
    n++;

    // datefinish
    //
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.datefinish_value;
    b[n].is_null = &i.datefinish_null;
    n++;

    // state
    //
    b[n].buffer_type = MYSQL_TYPE_LONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.state_value;
    b[n].is_null = &i.state_null;
    n++;

    // __isset
    //
    b[n].buffer_type = MYSQL_TYPE_BLOB;
    b[n].buffer = i.__isset_value.data ();
    b[n].buffer_length = static_cast<unsigned long> (
      i.__isset_value.capacity ());
    b[n].length = &i.__isset_size;
    b[n].is_null = &i.__isset_null;
    n++;
  }

  void access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  bind (MYSQL_BIND* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].buffer_type = MYSQL_TYPE_LONGLONG;
    b[n].is_unsigned = 0;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  init (image_type& i,
        const object_type& o,
        mysql::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace mysql;

    bool grew (false);

    // id
    //
    if (sk == statement_insert)
    {
      ::taxi::ID const& v =
        o.id;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, v);
      i.id_null = is_null;
    }

    // periodid
    //
    {
      ::taxi::NUMBER32 const& v =
        o.periodid;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.periodid_value, is_null, v);
      i.periodid_null = is_null;
    }

    // datestart
    //
    {
      ::taxi::DATE const& v =
        o.datestart;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.datestart_value, is_null, v);
      i.datestart_null = is_null;
    }

    // datefinish
    //
    {
      ::taxi::DATE const& v =
        o.datefinish;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_image (
        i.datefinish_value, is_null, v);
      i.datefinish_null = is_null;
    }

    // state
    //
    {
      ::taxi::NUMBER32 const& v =
        o.state;

      bool is_null (false);
      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_image (
        i.state_value, is_null, v);
      i.state_null = is_null;
    }

    // __isset
    //
    {
      ::taxi::_AutoPayment__isset const& v =
        o.__isset;

      bool is_null (false);
      std::size_t size (0);
      std::size_t cap (i.__isset_value.capacity ());
      mysql::value_traits<
          ::taxi::_AutoPayment__isset,
          mysql::id_blob >::set_image (
        i.__isset_value,
        size,
        is_null,
        v);
      i.__isset_null = is_null;
      i.__isset_size = static_cast<unsigned long> (size);
      grew = grew || (cap != i.__isset_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      ::taxi::ID& v =
        o.id;

      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // periodid
    //
    {
      ::taxi::NUMBER32& v =
        o.periodid;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.periodid_value,
        i.periodid_null);
    }

    // datestart
    //
    {
      ::taxi::DATE& v =
        o.datestart;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.datestart_value,
        i.datestart_null);
    }

    // datefinish
    //
    {
      ::taxi::DATE& v =
        o.datefinish;

      mysql::value_traits<
          ::taxi::DATE,
          mysql::id_longlong >::set_value (
        v,
        i.datefinish_value,
        i.datefinish_null);
    }

    // state
    //
    {
      ::taxi::NUMBER32& v =
        o.state;

      mysql::value_traits<
          ::taxi::NUMBER32,
          mysql::id_long >::set_value (
        v,
        i.state_value,
        i.state_null);
    }

    // __isset
    //
    {
      ::taxi::_AutoPayment__isset& v =
        o.__isset;

      mysql::value_traits<
          ::taxi::_AutoPayment__isset,
          mysql::id_blob >::set_value (
        v,
        i.__isset_value,
        i.__isset_size,
        i.__isset_null);
    }
  }

  void access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      mysql::value_traits<
          ::taxi::ID,
          mysql::id_longlong >::set_image (
        i.id_value, is_null, id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::persist_statement[] =
  "INSERT INTO `AutoPayment` "
  "(`id`, "
  "`periodid`, "
  "`datestart`, "
  "`datefinish`, "
  "`state`, "
  "`isset`) "
  "VALUES "
  "(?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::find_statement[] =
  "SELECT "
  "`AutoPayment`.`id`, "
  "`AutoPayment`.`periodid`, "
  "`AutoPayment`.`datestart`, "
  "`AutoPayment`.`datefinish`, "
  "`AutoPayment`.`state`, "
  "`AutoPayment`.`isset` "
  "FROM `AutoPayment` "
  "WHERE `AutoPayment`.`id`=?";

  const char access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::update_statement[] =
  "UPDATE `AutoPayment` "
  "SET "
  "`periodid`=?, "
  "`datestart`=?, "
  "`datefinish`=?, "
  "`state`=?, "
  "`isset`=? "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::erase_statement[] =
  "DELETE FROM `AutoPayment` "
  "WHERE `id`=?";

  const char access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::query_statement[] =
  "SELECT "
  "`AutoPayment`.`id`, "
  "`AutoPayment`.`periodid`, "
  "`AutoPayment`.`datestart`, "
  "`AutoPayment`.`datefinish`, "
  "`AutoPayment`.`state`, "
  "`AutoPayment`.`isset` "
  "FROM `AutoPayment`";

  const char access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::erase_query_statement[] =
  "DELETE FROM `AutoPayment`";

  const char access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::table_name[] =
  "`AutoPayment`";

  void access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_value = 0;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace mysql;
    using mysql::update_statement;

    callback (db, obj, callback_event::pre_update);

    mysql::transaction& tr (mysql::transaction::current ());
    mysql::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  erase (database& db, const id_type& id)
  {
    using namespace mysql;

    ODB_POTENTIALLY_UNUSED (db);

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::pointer_type
  access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  find (database& db, const id_type& id)
  {
    using namespace mysql;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  reload (database& db, object_type& obj)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace mysql;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::object_type >
  access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  query (database&, const query_base_type& q)
  {
    using namespace mysql;
    using odb::details::shared;
    using odb::details::shared_ptr;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) mysql::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::taxi::AutoPayment, id_mysql >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace mysql;

    mysql::connection& conn (
      mysql::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }
}

#include <odb/post.hxx>
